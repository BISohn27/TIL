# 레디스 캐시 사용

- 데이터의 원본을 빠르고 효율적으로 엑세스 할 수 있는 임시 데이터 자장소
- 캐시 도입 조건
  - 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나 매번 계산을 통해 데이터를 가져와야 함
  - 캐시에서 조회하는 것이 원본 데이터 저장소에서 요청하는 것보다 빨라야 함
  - 캐시에 저장된 데이터는 잘 변하지 않는 데이터
  - 캐시에 저장되는 데이터는 자주 조회되는 데이터
- 데이터 조회 시간 단축을 통한 응답 속도 개선
- 원본 데이터 저장소에서 데이터를 읽는 커넥션 줄임
- 캐시를 적절하게 배치하여 애플리케이션의 확장 가능
- CPU와 메모리를 사용하는 데이터의 경우 캐시를 사용함으로써 리소스 사용량 줄임
- 중요한 데이터를 캐시에 올릴 경우, 원본 데이터 저장소에 장애 발생 시 캐시에서 데이터를 가져옴으로써 장애 시간을 줄임
- 레디스를 캐시로 사용함으로써 얻는 효과
  - 다양한 자료구조를 제공하기 때문에 자료 구조 변환 과정 없이 바로 레디스에 저장 가능
  - 인메모리 데이터 저장소이기 때문에 조회 속도와 쓰기 속도가 굉장히 빠름
  - 고가용성 기능을 가지고 있기 때문에 센티널 또는 클러스터 사용 시 페일오버 사용 가능
  - 클러스터 사용 시 스케일 아웃을 쉽게 처리 가능



## 캐시 전략

### 읽기 전략 - look aside

- 조회하려는 데이터를 먼저 캐시에서 조회, 있으면 캐시의 데이터를 반환(**캐시 히트**)
- 조회하는 데이터가 없으면(**캐시 미스**) 데이터베이스에 접근하여 데이터를 가져오고, 가져온 데이터를 캐시에 저장하고 반환
- 레디스에 문제가 생겨 접근할 수 없는 상황이 바로 서비스 장애로 이어지지 않고, 데이터베이스에서 데이터를 가져올 수 있음
- 기존 레디스를 통해 데이터를 가져온은 연결이 매우 많았다면, 모든 커넥션이 한번에 원본 데이터베이스에 몰려 데이터베이스의 응답이 느려지거나 리소스를 많이 차지하는 성능 문제 발생 가능
- 데이터 변경을 원본 데이터베이스에만 반영할 경우, 캐시 미스가 빈번하게 일어나 성능 문제 발생
  - 데이터베이스에서 미리 데이터를 밀어넣어주는 **캐시 워밍** 작업을 하기도 함
  - 공연 예매 같은 경우, 사전에 공연 정보를 미리 캐시에 등록하여 예매 시 캐시 미스가 일어나지 않도록 하는 것이 효율적

### 쓰기 전략과 캐시의 일관성

- 캐시에 저장된 데이터는 원본 데이터의 복제본이기 때문에 원본 데이터와 동일한 값을 유지하는 것이 필수
- 데이터베이스에 변경 내역을 반영하고, 캐시에는 반영하지 않으면 **캐시 불일치** 현상 발생

#### write through

- 데이터베이스 업데이트할 때마다 매번 캐시에도 데이터를 함께 업데이트
- 항상 최신 데이터를 유지한다는 장점
- 데이터를 매번 2번 저장소에 저장하여 데이터를 쓸 때 많은 시간이 소모될 수 있다는 단점
- 캐시는 다시 사용할 데이터를 저장하는 것이 좋기 때문에 다시 사용하지 않는 데이터도 매번 업데이트 하는 것은 비효율적
- 이 방식을 사용할 때에는 만료 시간을 사용하는 것이 권장

#### cache invalidation

- 데이터베이스에 값을 업데이트할 때마다 캐시에서는 해당 데이터를 삭제
- **write through** 단점을 보완

#### write behind(write back)

- 쓰기가 빈번하게 발생하는 서비스일 때 사용
- 데이터를 가장 먼저 접근하는 캐시를 업데이트하고, 건수나 특정 시간 간격 등에 따라 비동기적으로 데이터베이스에 업데이트
- 데이터가 실시간으로 정확한 데이터가 아니어도 되는 경우에 유용 (유튜브의 좋아요 등)
- 캐시에 문제가 생겨 데이터가 날아갈 경우 최대 5분 동안의 데이터가 날아갈 수 있다는 위험 감수



## 캐시에서의 데이터 흐름

- 캐시는 원본 데이터 베이스의 적은 양의 데이터를 보관하는 서브셋
- 인메모리 저장소인 레디스는 특히 훨씬 적은 양을 보관할 수 밖에 없음
- 항상 데이터가 가득차지 않게 일정 양의 데이터를 유지해야 함
- 새로운 데이터는 저장되고 기존 데이터는 삭제될 수 있도록 관리
- 적절한 TTL 값을 저장하는 것이 좋음

#### 만료 시간

- 특정 키에 만료 시간(TTL)을 적절히 설정하여, 레디스에서 자동으로 삭제되도록 함으로써 캐시 데이터를 관리
- `EXPIRE` 커맨드로 초 단위 만료 시간 설정
- 기존 키에 새로운 값을 덮어 쓸 경우, 이전에 설정한 만료 시간은 유지되지 않음
- 레디스에서 만료된 키 관리 방식
  - passive 방식
    - 클라이언트에서 만료된 키에 접근할 때 만료된 키를 삭제
    - 클라이언트에서 접근하지 않는 만료된 키가 존재할 수 있음
  - active 방식
    - TTL 값이 있는 키 중 20개를 랜덤하게 뽑은 뒤 만료된 키를 삭제
    - 25% 이상 키가 삭제되었다면 다시 20개를 랜덤하게 뽑은 뒤 삭제
    - 1초에 10번씩 수행

#### 만료 키 삭제 정책

- 메모리의 용량을 초과하는 양의 데이터가 저장되면 내부 정책을 사용하여 어떤 키를 삭제할지 결정
- `maxmemory`: 데이터의 최대 저장 용량 설정
- `maxmemory-policy`: 용량 초과할 때 처리 방식 설정

##### Noeviction

- 용량이 초과되더라도 키를 삭제하지 않고, 더이상 데이터를 저장할 수 없다는 에러만 반환
- 데이터 관리를 캐시가 아닌 애플리케이션에서 관리한다는 의미
- 장애 상황으로 이어지지 않게 관리자가 데이터를 직접 지워야 함으로 레디스를 캐시로 사용할 때 권장하지 않는 설정값
- 데이터가 가득 찼을 때, 캐시 내부적으로 삭제하는 것이 위험하다고 판단되는 경우에 사용

##### LRU(Least Recently Used) eviction

- 가장 최근에 사용되지 않은 데이터를 삭제하는 정책
- 최근에 엑세스되지 않은 데이터는 나중에도 엑세스될 가능성이 낮을 것이라 가정
- 나중에 사용될 가능성이 있는 데이터를 유지하는 것이 캐시의 목표
- `volatile-lru`: 만료 시간이 설정되어 있는 키에 한해서 LRU 방식으로 키를 삭제
  - 임의적으로 삭제하면 안되는 데이터에는 만료 시간을 설정하지 않음으로써 삭제될 키와 삭제되면 안되는 키를 구분해야 될 때 유용
  - 저장된 모든 키에 만료 시간이 설정되지 않을 경우 장애 발생 가능 (삭제할 수 있는 키가 없기 때문에 데이터 저장 에러 반환)
- `alleys-LRU`: 모든 키에 대해 LRU 알고리즘을 이용해 데이터 삭제
  - 공식 문서에서 잘 모르겠으면 이 설정을 하라고 권장
  - 적어도 메모리가 가득 차 장애가 발생하는 상황은 방지

##### LFU(Least Frequently Used) eviction

- 자주 사용되지 않은 데이터부터 삭제하는 정책
- 자주 사용되지 않는 데이터는 나중에도 사용될 가능성이 낮다는 가정
- 키를 엑세스하는 패턴에 따라 우선 순위가 유동적으로 바뀐 다는 점에서 LRU보다 특정 케이스에서는 효율적
- 키가 오랫동안 사용되지 않더라도 과거에 많이 사용되었다면 나중에도 사용될 수 있다는 가정하에 우선순위가 높아짐
- `volatile-lfu`: 만료 시간이 설정되어 있는 키에 한해서 LFU 방식으로 삭제
  - 특정 상황에서는 장애 발생 가능
- `alleys-lfu`: 모든 키에 대해 LFU 알고리즘 적용하여 데이터 삭제

- LRU, LFU는 모두 근사 알고리즘으로 정확하게 찾아서 데이터를 삭제하는게 근사치로 찾아내 효율적으로 데이터를 삭제



##### RANDOM evicition

- 저장된 키 중 하나를 임의로 골라 삭제
- 삭제될 키를 계산하지 않아도 된다는 점에서 레디스에 부하를 줄이는 방법
- 나중에 사용될 수 있는 키가 랜덤으로 삭제 될 수 있기 때문에 데이터를 원본 데이터 저장소에서 다시 가져와 저장해야 하는 비효율 발생
- LRU, LFU 모두 근사 알고리즘으로 레디스 성능에 크게 영향을 주지 않기 때문에 두 알고리즘에 비해 권장되지 않는 정책
- `volatile-random`: 만료 시간이 설정돼 있는 키에 한해 랜덤하게 키를 삭제
- `alleys-random`: 모든 키에 대해 랜덤하게 키를 삭제

##### volatile-ttl

- 만료 시간이 가장 작은 키를 삭제
- 삭제 예정 시간이 얼마 남지 않은 키를 추출해 해당 키를 삭제
- 근사 알고리즘을 통해 삭제
- 저장된 모든 키를 스캔하면서 만료 시간을 비교하지 않아도 돼 간단하게 키를 찾아낼 수 있음



### 캐시 스탬피드 현상

- 모든 키에 만료 시간을 설정하는 것이 좋지만, 대규모 트래픽 환경에서는 예기치 못한 상황 발생 가능
- 여러 애플리케이션에서 바라보던 키가 만료되어 삭제될 경우 **look-aside** 읽기 전략에서는 여러 애플리케이션이 한번에 데이터베이스에 읽어오는 과정을 거침 (**중복 읽기**)
- 각 애플리케이션에서 읽어온 데이터를 레디스에 한번에 쓰기 때문에 여러번 쓰기가 반복되는 과정 거침 (**중복 쓰기**)
- 데이터베이스 연산이 많이 필요한 데이터를 캐시에 저장하는 경우가 많기 때문에, 무거운 쿼리를 실행하는 중복 읽기 작업은 데이터베이스에 부하를 줌
- 한번 캐시 스탬피드 현상이 발생하면, 더 많은 데이터가 이 현상의 영향을 받아 더 큰 문제가 발생하는 **계단식 실패** 현상 발생

##### 캐시 스탬피드 현상을 줄이는 여러 방법

- 적절한 만료 시간 설정
  - 여러 애플리케이션에서 한꺼번에 접근해야 하는 데이터이고, 반복적으로 사용돼야 하는 데이터라면 만료 시간을 충분히 길게 설정
- 선 계산
  - 캐시 스탬피드는 데이터가 만료되는 시점에 여러 애플리케이션에서 동시다발적으로 이를 인지하고, 작업을 동시에 진행해서 발생
  - 키가 만료되기 전에 미리 갱신해주면, 불필요한 프로세스를 줄일 수 있음
  - `ttl - (random() * expiry_gap) > 0`
    - 랜덤 확률로 만료되기 전에 데이터베이스에서 데이터를 가져와 만료 시간을 갱신
    - 상황에 따라 캐시 스탬피드 현상을 줄일 수 있기 때문에 전체적인 성능은 향상시키는 방법일 수 있음
    - `expiry_gap` 값을 적절히 설정하여, 불필요한 작업이 늘어나 성능에 영향을 주는 것을 피함
- PER 알고리즘
  - 캐시 값이 만료되기 전 언제 데이터베이스에 접근해서 값을 읽어오면 되는지 최적의 시점을 계산
  - `currentTime - (timeToCompute * beta * log(rand())) > expiry`
    - currentTime: 현재 남은 만료 시간
    - timeToCompute: 캐시된 값을 다시 계산하는데 걸리는 시간
    - beta: 기본적으로 1.0보다 큰 값
    - rand: 0과 1사이 랜덤 값
    - expiry: 키를 재설정할 때 새로 넣어줄 만료 시간
  - 만료 시간이 가까워질수록 currentTime와 expiry 사이의 차이가 작아지며, rand 반환한 무작위 값에 의존하기 때문에 참이 될 확률이 높아짐
  - 만료시간이 가까워질수록 더 자주 만료된 캐시 항목을 확인하게 됨



## 세션 스토어

- 세션: 서비스를 사용하는 클라이언트의 상태
  - 유저가 장바구니에 어떤 물건을 담았는지, 최근에 봤던 아이템은 어떤 것이었는지 등의 정보를 세션에 저장하면 로그인 시 해당 정보를 유지
  - 사용자가 서비스의 각 페이지에서 보내는 시간을 저장한 뒤 이를 이용해 사용자 행동을 분석하는데 활용
- 서비스가 확장되어 웹 서버가 여러 대로 늘어나는 상황
  - **sticky session**
    - 웹 서버별로 세션 스토어를 따로 관리하면, 특정 유저는 자신이 처음 접근한 서버에만 요청을 보내야 함
    - 특정 웹서버에 요청이 몰리는 상황에서 자신의 세션 스토어가 저장된 유저는 다른 서버를 사용하지 못하고 해당 서버만 사용
  - **all-to-all**
    - 모든 세션 정보를 모든 웹 서버에 복제해서 저장
    - 유저를 여러 서버에 분산시킬 수 있지만 모든 서버에 해당 유저의 세션 정보를 저장해야 되기 때문에 저장공간 낭비 발생
    - 유저는 한번에 한 서버만 사용하기 때문에 다른 서버에 존재하는 세션 정보는 그 시점에서 필요 없음
  - **데이터베이스 사용**
    - 각 유저는 세션이 활성화 되어 있는 동안 세션 스토어에 활발하게 엑세스
    - 서비스가 커져 유저가 많아지면 데이터베이스에 부하가 발생하여 전반적인 응답 속도 저하
  - **레디스 사용**
    - 여러 웹서버에서 레디스를 통해 세션 정보를 조회하므로 효율적으로 트래픽 분산 및 데이터 일관성
    - 레디스의 엑세스 속도는 관계형 데이터베이스보다 빠르고, 간편하게 데이터 저장 가능
    - hash 자료 구조는 세션 데이터를 저장하기에 좋음

### 캐시와 세션의 차이

- 레디스를 캐시로 사용할 때에는 일반적으로 look-aside 전략을 사용하여 데이터베이스의 서브셋으로 동작
- 캐시 내 데이터가 유실되도 해당 데이터를 데이터베이스에서 찾을 수 있음
- 캐시에 저장된 데이터는 여러 애플리케이션에서 공유
- 세션 스토어에 저장된 데이터는 각 사용자에 할당되어 특정 사용자 ID에 유효
- 사용자가 로그인하면 세션 정보는 세션 스토어에만 저장하기 때문에, 레디스를 세션 스토어로 사용하면 해당 데이터를 관계형 데이터베이스가 아닌 세션 스토어에만 저장
- 로그아웃으로 세션이 종료될 때 해당 데이터를 영구히 보관할지 결정
- 세션 스토어가 가지고 있는 데이터가 유일하기 때문에 세션 스토어에 장애가 발생할 경우 내부 데이터 손실 가능
- 세션 스토어에 레디스를 사용할 때에는 캐시로 사용할 때보다 더 신중한 운영 필요