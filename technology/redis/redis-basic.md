# 레디스 기본 개념

- 키-값 형태의 데이터 저장소
- 레디스의 모든 데이터는 키와 연결되어 저장, 저장된 데이터를 검색할 때에는 항상 키를 식별자로 사용



## 레디스의 자료 구조

### string

- 데이터를 저장할 수 있는 가장 간단한 구조

- 최대 512MB 문자열 저장 가능

- 이진 데이터를 포함한 모든 종류의 문자열이 binary-safe하게 처리

  - JPEG 이미지와 같은 바이트 값
  - HTTP 응답 값

- 키와 실제 저장되는 아이템이 일대일로 연결되는 유일한 자료구조

- `SET [key] [value]`

  - 만약 키에 다른 값이 연결되어 있으면, 기존 값을 새로 입력된 값으로 대체
  - 저장되어 있는 값의 자료구조(string)에 관계 없이 새로 입력된 값의 자료 구조로 대체

- `SET [key] [value] NX`

  - 지정한 키에 연결된 값이 없을 때에만 새로운 키를 저장

- `SET [key] [value] XX`

  - 키가 이미 존재할 때에만 기존 값을 새로운 값으로 대체
  - 새로운 키를 생성하지는 않음

- 숫자 형태의 데이터도 저장 가능하기 때문에 `INCR`, `INCRBY` 커맨드로 저장된 숫자를 원자적으로 조작

  - `INCR`: 저장된 데이터를 1씩 증가
  - `INCRBY`: 입력한 값만큼 데이터 증가

  - `DECR`, `DECRBY`: 값 감소
  - 원자적으로 조작하기 때문에 여러 클라이언트 간 경쟁 상태 없음

- `MGET`, `MSET` 커맨드를 통해 한번에 여러 키를 조작할 수 있음



### list

- 순서를 가진 목록

- 최대 42억여 개의 아이템을 저장

- 일반적인 배열처럼 인덱스로 데이터 접근 가능

- 서비스에서 스택이나 큐로 사용

- `LPUSH`: 왼쪽(처음)에 삽입

- `RPUSH`: 오른쪽(끝)에 삽입

- `LRANGE`: 왼쪽에서부터 조회 (0 -1 -> 0부터 끝까지)

- `LPOP`: 왼쪽에 있는 값을 하나 반환하고 list에서 삭제, 숫자 사용 시 해당 숫자만큼 반환하고 삭제

- `LTRIM`: 시작과 끝 인덱스를 인자로 받아 지정한 범위에 속하지 않은 아이템을 모두 삭제, 삭제한 아이템을 반환하지는 않음

  - `LPUSH`와 `LTRIM`을 같이 사용하면 고정된 크기의 큐를 쉽게 유지 가능

    ```cmd
    LPUSH logdata <data>
    LTRIM logdata 0 999
    ```

  - 배치 처리로 삭제하는 것보다는 매번 큐의 데이터를 삭제하는게 O(1) 시간이 걸리므로 효율적
  - 인덱스나 데이터를 이용해 list의 중간 데이터에 접근할 때에는 O(n) 시간 걸림 (연결 리스트)

- `LINSERT`: 원하는 데이터의 앞(`BEFORE`)이나 뒤(`AFTER`)에 데이터를 추가

  - `LINSERT <key> BEFORE <기존 데이터> <추가할 데이터>`

- `LSET`: 지정한 인덱스의 데이터를 신규 입력된 데이터로 대체
  - list의 범위를 벗어난 인덱스를 입력하면 에러 반환
- `LINDEX`: 입력된 인덱스의 데이터 확인



### hash

- 필드-값을 가진 아이템 집합
- 필드는 하나의 hash 내에서 유일, 필드와 값 모두 문자열 데이터로 저장
- 객체로 표현하기 적절한 자료 구조이기 때문에 관계형 데이터베이스의 데이터로 변환하는 것이 용이
- 동적으로 필드를 추가하는 것이 가능
- 각 아이템마다 다른 필드를 가질 수 있음
- 관계형 데이터베이스 테이블에는 미리 합의된 칼럼 데이터만 저장할 수 있음
- `HSET`: 아이템을 저장, 한번에 여러 필드-값 쌍을 저장할 수 있음
- `HGET`: hash 내 필드에 저장된 데이터를 가져옴
  - `HGET <key> <field>`
- `HMGET`: 하나의 hash 내 여러 필드에 저장된 데이터를 한번에 가져옴
  - `HMGET <key> <field1> <field2>`
- `HGETALL`: hash 내 모든 필드-값 쌍을 차례로 가져옴
  - `HGETALL <key>`



### set

- 정렬되지 않은 문자열의 모음
- 중복 저장되지 않으며, 교집합, 합집합, 차집합 등의 집합 연산과 관련된 커맨드 제공
  - 객체 간의 관계 계산이나 유일한 원소를 구하는 경우에 사용
- `SADD`: set에 아이템 저장, 한번에 여러 개의 아이템 저장 가능, 저장되는 실제 아이템 수 반환
- `SMEMBERS`: 저장된 전체 아이템 출력, 저장된 순서에 관계 없이 랜덤한 순서로 데이터 출력
- `SREM`: 원하는 데이터 삭제
- `SPOP`: 내부의 아이템 중 랜덤으로 하나의 아이템을 반환하는 동시에 해당 아이템 삭제
- `SUNION`(합집합), `SINTER`(교집합), `SDIFF`(차집합)



### sorted set

![Redis Sorted Sets Explained. Try to understand Sorted Sets with a… | by  Dunith Danushka | Analytics Vidhya | Medium](https://miro.medium.com/v2/resize:fit:1160/1*tez9rC_b4Q0TQO5A-AeH2Q.png)

- 스코어 값에 따라 정렬되는 고유한 문자열의 집합

- 모든 아이템은 스코어-값 쌍을 가짐

- 저장될 때 스코어 값으로 정렬되어 저장

- 같은 스코어를 가진 아이템은 데이터의 사전 순으로 정렬 저장

- 데이터는 중복 없이 유일하게 저장되어 set과 유사하고, 각 아이템은 스코어라는 데이터에 연결되어 있어 hash랑도 유사

- 모든 아이템은 스코어 순으로 정렬되어 있어, list처럼 인덱스를 이용해 각 아이템에 접근 가능

- sorted set은 스코어를 기준으로 정렬되어 저장되기 때문에 이진 탐색이 가능하여 O(logn)으로 접근 가능, list의 경우 연결 리스트이기 때문에 인덱스로 접근 시 O(n) 소요되어 인덱스 접근이 필요할 경우 sorted set이 더 빠름

- `ZADD`: sorted set에 아이템을 저장

  - `ZADD <key> <score> <value>`

  - 만약 데이터가 이미 존재하면 스코어만 업데이트 되어 스코어 재정렬만 일어남
  - 지정한 키가 존재하지 않을 경우에는 sorted sey를 새로 생성
  - 지정한 키가 존재하지만 sorted set이 아닐 경우에는 오류 반환
  - **스코어**는 **배정밀도 부동소수점 숫자**를 문자열로 표현한 값이여야 함
  - 옵션
    - `XX`: 아이템이 이미 존재할 경우에만 스코어를 업데이트
    - `NX`: 아이템이 존재하지 않을 경우에만 신규 삽입, 기존 아이템의 스코어는 업데이트하지 않음
    - `LT`: 업데이트하고자 하는 스코어가 기존 아이템의 스코어보다 작을 때에만 업데이트, 아이템이 존재하지 않으면 새로운 데이터 삽입
    - `GT`: 업데이트하고자 하는 스코어가 기존 아이템의 스코어보다 클 때에만 업데이트, 아이템이 존재하지 않으면 새로운 데이터 삽입

- `ZRANGE`: sorted set에 저장된 데이터를 조회, **start**와 **stop** 범위를 항상 입력

  - `ZRANGE <key> <start> <stop> [BYSOCRE | BYLEX] [REV] [LIMIT offset count] [WITHSCORE]`
  - `WITHSCORE` 옵션: 데이터와 함께 스코어 값을 차례대로 출력
  - `REV` 옵션: 데이터를 역순으로 출력
  - `BYSOCRE` 옵션: start와 stop이 조회하려는 스코어 범위(최소, 최대)로 사용 ('(' 문자열은 열린 범위 설정)
    - `-inf` - 아래로 전부, `+inf` - 위로 전부
    - `REV` 옵션 사용 시 start와 stop 전달 순서를 뒤집어야 함
  - `BYLEX` 옵션: 사전식 순서로 특정 아이템을 조회, start와 stop을 사전식으로 조회할 문자열로 사용
    - '(': 입력한 문자열을 포함
    - '[': 입력한 문자열을 제외



### 비트맵

-  독자적인 자료 구조는 아님
- string 자료 구조에 비트 연산을 수행하도록 확장한 형태
- 512MB 문자열을 2^32 비트를 가지고 있는 비트맵으로 사용
- 정수 형태로 ID가 저장되는 유저를 관리할 때, 비트맵을 사용하여 40억 개의 유저 아이디가 할당되어 있는지를 검사(1 0)
- `SETBIT`: 비트 저장
- `GETBIT`: 비트 조회
- `BITFIELD`: 한번에 여러 비트를 저장
- `BITCOUNT`: 1로 설정된 비트 개수 카운팅



### hyperloglog

- 대량의 데이터에서 고유한 원소의 개수(카디널리티)를 매우 적은 메모리로 추정하는 확률 자료구조
- 원소를 정확하게 저장하는 set과 달리 최대 12KB로 0.81% 오차 범위 내에서 고유 원소 수를 추정
- 메모리 사용량은 원소 개수와 무관, 최대 2^64개의 아이템을 저장
- 방문자 수, 고유 검색어 수, 고유 이벤트 수, 광고 클릭한 고유 사용자 수 등 정확한 값이 필요하지 않는 통계 추정에 사용
- `PFADD` 커맨드로 아이템 저장, `PFCOUNT` 커맨드로 저장된 아이템 개수(카디널리티)를 추정



### Geospatial

- 경도와 위도 데이터 쌍의 집합을 간편하게 지리 데이터로 저장
- 데이터는 sorted set으로 저장, 하나의 자료 구조 안에 키는 중복 저장되지 않음



## 레디스의 키 관리

- stream, set, sorted set, hash 처럼 하나의 키에 여러 개의 아이템을 가지고 있는 자료 구조에서는 명시적으로 키를 생성하거나 삭제 하지 않아도 자동으로 생성, 삭제
- 키 생성, 삭제 규칙
  - 키가 존재하지 않을 때 아이템을 넣으면 아이템 삽입 전 빈 자료 구조를 생성
    - 저장하고자 하는 키에 다른 자료 구조가 이미 생성돼 있을 때 아이템 추가 작업은 에러
  - 모든 아이템을 삭제하면 키도 자동으로 삭제(스트림 제외)
  - 키가 없는 상태에서 키 삭제, 아이템 삭제, 자료 구조 크기 조회 같은 읽기 전용 커맨드를 수행하면 예러 반환 대신 아이템이 없는 것처럼 동작

### `EXISTS <key> [key...]`

- 키 존재하는지 확인

### `KEYS <pattern>` 

- 저장된 모든 키를 조회하고, 글롭 패턴 스타일로 동작
- **KEYS** 커맨드 동작 시 조회 완료될 때까지 모든 get, set 동작은 대기 상태가 되기 때문에 싱글 스레드로 동작하는 레디스에서는 위험한 커맨드



### `SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]`

- KEYS 커맨드를 대체
- 커서 기반으로 특정 범위의 키만 조회할 수 있기 때문에 비교적 안전
- 조회 시 첫번째 줄에 다음 커서 위치가 반환되기 때문에 커서 값이 0이 될 때까지 조회 가능
- 일반적으로 반환되는 값은 10개이며, count 옵션을 통해 반환할 키 개수를 조절할 수 있음
  - 정확하게 count에 해당하는 키 개수가 반환되는건 아니고, 데이터가 저장된 형상에 따라 추가적으로 더 읽어서 반환할 수 있음
  - 한번에 반환하는 값이 커지면 조회에 시간이 오래 걸리기 때문에 시스템에 영향 줄 수 있음
- match 옵션을 사용하면, 특정 패턴의 키를 조회할 수 있음
  - 데이터를 필터링 없이 스캔한 후 스캔한 데이터에서 패턴에 맞는 키를 반환하는 방식으로 동작하기 때문에 적은 수의 결과나 빈 값이 반환될 수 있음 (조회한 커서 범위에서 해당 패턴으로 된 키가 없을 경우)
- type 옵션을 사용하면 지정한 타입의 키만 조회
  - match와 동일하게 스캔한 데이터에서 필터링을 진행하기 때문에 원하는 타입을 조회할 때까지 오래 걸릴 수 있음

- `SSCAN`, `HSCAN`, `ZSCAN`은 set, hash, sorted set의 `SMEMBERS`, `HGETALL`, `ZRANGE WITHSCORES`의 시스템 영향도를 줄인 커맨드



### SORT

- list, set, sorted set에서만 사용 가능한 커맨드
- 키 내부의 아이템을 정렬해서 반환



### RENAME / RENAMENX

- 키의 이름을 변경하는 커맨드
- `RENAMENX`는 변경할 키가 존재하지 않을 때에만 동작



### COPY

- `COPY source destination [DB destination-db] [REPLACE]`
- source 키를 destination 키에 복사
- destination에 지정한 키가 이미 존재하는 경우 에러를 반환
- `REPLACE` 옵션 지정 시 destination 키를 삭제 후 값을 복사



### TYPE

- 지정한 키의 자료 구조 타입을 반환



### OBJECT

- `OBJECT <subcommand> <key>`
- 키에 대한 상세 정보를 반환



### FLUSHALL

- `FLUSHALL [ASYNC | SYNC]`
- 저장된 모든 키를 삭제
- 기본적으로 동기적으로 동작하기 때문에 모든 데이터가 삭제한 경우에만 OK를 반환
- 커맨드가 실행되는 도중에는 다른 응답 처리 불가
- 비동기 처리 옵션을 사용하면 백그라운드로 실행하여 커맨드가 수행되었을 때 존재했던 키만 삭제
- flush 수행 중 새로 생성된 키는 삭제되지 않음
- `lazyfree-lazy-user-flush` 옵션을 사용하면 비동기 옵션 없이 백그라운드로 키 삭제 작업 동장
  - 버전 7 기준으로 이 옵션의 기본 값은 `no`(사용 안함)



### DEL

- `DEL <key> [key...]`
- 키와 키에 저장된 모든 아이템을 삭제하는 커맨드
- 기본적으로 동기적으로 동작



### UNLINK

- `UNLINK <key> [key...]`
- 키와 키에 저장된 모든 아이템을 삭제하는 커맨드
- 백그라운드에서 다른 스레드에 의해 처리하며, 우선 키와 연결된 데이터의 연결을 끊음
- set, list, sorted set 등 하나의 키에 여러 개의 아이템이 저장된 경우, DEL 커맨드는 키에 저장된 아이템 수에 따라 다른 커맨드 블록을 유발
- 키에 저장된 아이템이 많은 경우 DEL이 아닌 UNLINK로 삭제하는 것이 좋음
- `lazyfree-lazy-user-del`옵션을 적용하면 DEL 커맨드는 UNLINK로 동작
  - 버전 7 기준으로 이 옵션의 기본 값은 `no`(사용 안함)



### EXPIRE

- `EXPIRE <key> seconds [ NX | XX | GT | LT ]`
- 키가 만료될 시간을 초 단위로 정의
- 옵션
  - NX : 해당 키에 만료 시간이 정의되어 있지 않을 경우에만 커맨드 수행
  - XX : 해당 키에 만료 시간이 정의되어 있을 경우에만 커맨드 수행
  - GT : 해당 키에 적용된 만료 시간보다 새로 입력한 시간이 더 클 때에만 수행
  - LT : 해당 키에 적용된 만료 시간보다 새로 입력한 시간이 더 작을 때에만 수행



### EXPIREAT

- `EXPIREAT <key> <unix-time-seconds> [ NX | XX | GT | LT ]`
- 키가 유닉스 타임스탬프에 만료될 수 있도록 직접 지정



### EXPIRETIME

- `EXPIRETIME <key>`
- 키가 삭제되는 유닉스 타임스탬프를 초 단위로 반환
- 키가 존재하지만 만료 시간이 설정되어 있지 않을 때에는 -1, 키가 없을 때에는 -2 반환



### TTL

- `TTL <key>`
- 키가 몇 초 뒤에 만료되는지 반환
- 키가 존재하지만 만료 시간이 설정되어 있지 않을 때에는 -1, 키가 없을 때에는 -2 반환