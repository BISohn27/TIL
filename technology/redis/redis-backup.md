# 레디스 데이터 백업

- 레디스는 모든 데이터를 메모리에서 관리하기 때문에 장애로 인해 레디스 인스턴스가 재시작 될 때 모든 데이터가 손실될 가능성이 있음
- 복제 구조를 사용하면, 복제본에 데이터가 저장되어 있어 백업이 필요 없을 수 있지만 복제는 가용성을 위한 것이라 별도의 백업 필요
  - 개발자의 실수 혹은 프로그램 상의 버그로 인해 마스터 노드에 의도하지 않은 데이터 삭제 커맨드를 실행할 경우 복제 노드에도 데이터 삭제 커맨드가 실행되어 데이터가 삭제될 수 있음
- 레디스의 복제 방식은 **RDB**와 **AOF** 두가지 존재
  - RDB: 일정 시점에 저장된 데이터 전체를 스냅샷 형태로 저장, 바이너리 형태로 저장
  - AOF: 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록, 복원 시 기록된 쓰기 작업을 차례대로 읽어 복원, 레디스 프로토콜 형태로 저장
- 두 방식 모두 장단점이 존재
  - RDB는 시점 단위로 여러 백업본을 저장할 수 있고, 복원이 빠름, 특정 시점으로 복구는 불가능
  - AOF는 RDB 파일보다 크기가 크고, 주기적으로 압축해 재작성해야 하지만 원하는 시점으로 복구할 수 있음
- 관계형 데이터베이스 만큼의 데이터 안정성을 위해서는 두 가지 백업 방식을 동시에 사용하는 것이 권장
- 레디스는 AOF 파일이 있으면, 더 안전하다고 판단되는 AOF 파일을 복원 시 사용하지만, 데이터의 안정성을 위해서는 주기적인 RDB 스냅숏을 갖는 것이 좋음
- 레디스의 데이터 복원은 서버 재시작 시에만 사용, 레디스 인스턴스 실행 도중에는 데이터 복원 파일을 읽어 올 수 없음
- 레디스 서버 재시작 시 AOF 파일과 RDB 파일을 읽어 복원, AOF 파일과 RDB 파일이 둘다 있을 경우, AOF 파일을 우선으로 로드



## RDB

- 일정 주기마다 메모리에 존재하는 전체 데이터를 스냅샷 형태로 파일에 저장
- 원격 저장소에 파일을 옮겨 2차 백업을 수행할 경우 데이터 센터 장애와 같은 큰 장애에도 대처 가능
- 지정한 시간 단위로 파일을 저장하기 때문에 저장 시점부터 장애 발생한 직전까지의 데이터는 손실 될 수 있음
- RDB 파일 생성 방법
  - 설정 파일에 특정 조건에 파일이 자동으로 저장되도록 설정
  - 사용자가 원하는 시점에 커맨드를 사용하여 수동으로 파일 생성
  - 복제 기능 사용 시 자동으로 RDB 파일 생성



### 특정 조건에 자동으로 RDB 파일 생성

```cmd
save <기간(초)> <기간 내 변경된 키의 개수>
dbfilename <RDB 파일 이름>
dir <RDB 파일이 저장될 경로>
```

- 일정한 시간 동안 변경된 키의 개수가 조건에 맞을 때 자동으로 RDB 파일 저장
- `dbfilename`로 설정된 이름으로 저장
- `dir`로 설정된 경로에 저장
- `save 900 1`: 900초 동안 1개 이상의 키가 변경된 경우 파일 생성
- `save`: 파일을 저장하고 싶지 않을 경우에는 빈 문자열로 설정
- `CONFIG SET save ""`로 레디스 인스턴스 실행 중 설정 변경 가능하고, `CONFIG REWITE` 커맨드로 `redis.conf`파일 재작성하여 재시작해도 해당 설정이 적용되도록 함



### 수동으로 RDB 파일 생성

- `SAVE` 명령어를 실행하면 수동으로 RDB 파일을 저장할 수 있지만, 레디스 인스턴스에 연결된 다른 클라이언트는 파일 생성이 완료될 때까지 아무런 작업을 수행할 수 없음
- `BGSAVE` 명령어를 실행하면 `fork`를 호출해 자식 프로세스를 생성하여 자식 프로세스 백그라운드에서 RDB 파일을 생성
  - 자식 프로세스에서 백그라운드로 실행하기 때문에 부모 프로세스에서 다른 클라이언트 작업을 기존대로 수행 가능
  - 이미 명령어가 실행되는 중에 `BGSAVE` 명령어를 실행하면 에러 반환
  - `SCEDULE` 옵션을 사용해서 백업이 완료된 후 커맨드가 실행되도록 할 수 있음
  - `LASTSAVE` 명령어를 통해 마지막으로 파일을 생성한 시점의 유닉스 타임스탬프를 확인 가능



### 복제를 사용할 경우 자동으로 RDB 파일 생성

- `REPLICAOF` 커맨드를 이요해 복제를 요청
- 마스터 노드에서는 RDB 파일을 새로 생성
- 생성한 RDB 파일을 복제본에 전달
- 이미 복제 연결이 되어 있는 상태에서 네트워크 문제 등으로 일정 시간 복제가 끊겼다 복구된 경우에도 RDB 파일을 전송



## AOF

- 레디스 인스턴스에서 수행된 모든 쓰기 작업의 로그를 차례대로 기록

- 삭제 커맨드로 데이터를 날렸어도, AOF 파일에서 해당 커맨드를 지우고 복구 가능

  ```cmd
  appendonly yes
  appendfilename "appendonly.aof"
  appenddirname "appendonlydir"
  ```

  - 위의 옵션을 통해 주기적으로 `appendfilename` 이름으로 `appenddirname` 디렉토리에 AOF 파일 저장
  - 7.0 버전 이상부터 AOF 파일은 여러 개로 저장
  - `appenddirname`은 `dir` 옵션 하위 디렉토리 이름, 경로 지정은 안됨

- 레디스 서버의 메모리에 영향을 주는 커맨드만 기록

- 레디스 프로토콜 형식으로 저장

- AOF 파일에는 사용자 실행한 커맨드가 그대로 저장되는 것은 아님

  - `BRPOP`처럼 실행 당시에 블록킹이 필요한 커맨드의 경우 AOF 파일에 저장될 때에는 `RPOP`으로 저장
  - `INCRBYFLOAT`처럼 부동소수점을 더해주는 커맨드도 실행되는 아키텍처에 따라 처리하는 방식이 다를 수 있어 직접 증분된 값을 `SET`하는 명령어가 실행

- AOF 파일은 Append-Only 방식이기 때문에 인스턴스 실행 시간에 비례해서 파일 크기가 커짐



### AOF 파일 재구성

- 점점 커지는 백업 파일을 주기적으로 합축하는 **rewrite** 작업 필요

- 특정 조건에 자동으로 재구성 하도록 설정 가능

- 사용자가 원하는 시점에 커맨드를 사용하여 재구성 가능

- 재구성 과정

  - 레디스 메모리에 있는 데이터를 읽어와 새로운 파일을 저장하는 형태로 동작

  - `of-use-rdb-preamble`이 `yes`로 설정되어 있으면, RDB 파일 형태로 저장

  - 7.0 이하 버전에서는 하나의 AOF 파일 안에 RDB 내용과 레디스 프로토콜 내용이 함께 저장

    - 과정

      1. `fork`를 이용해 자식 프로세스 생성

      2. 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장

      3. 백그라운드로 위의 작업이 진행되는 동안 변경된 내역은 기존 AOF 파일과 인메모리 버퍼에 동시에 저장

      4. AOF 재구성 작업이 끝나면, 인메모리 버퍼에 저장된 내용을 임시 파일 마지막에 추가

      4. 생성된 임시 파일을 기존 파일에 덮어씌움

    - 단점

      - 임시 파일로 재구성 하는 과정에서 발생한 변경 내역이 인메모리 버퍼와 기존 AOF 파일에 이중으로 저장
      - AOF 파일 내에 바이너리 형태와 레디스 프로토콜 텍스트 형태가 함께 저장되어 수동 처리 복잡

  - 7.0 이상 버전에서는 RDB 파일(고정 영역)과 AOF 파일(증분 영역)로 나눠서 저장

    - 매니페스트 파일로 현재 어느 파일을 사용하고 있는지 기록

    - AOF를 재구성할 때마다 RDB와 AOF의 파일명의 번호와 매니페스트 파일 내부의 시퀀스 값을 1씩 증가

    - 과정

      1. `fork`를 사용해 자식 프로세스 생성

      2. 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장

      3. 재구성 과정에서 변경된 내역은 신규 AOF 파일에 저장

      4. 재구성 과정이 끝나면 임시 매니페스트 파일을 생성한 뒤 변경된 버전으로 매니페스트 파일 내용을 업데이트

      5. 생성된 임시 매니페스트 파일로 기존 매니페스트 파일을 덮어 씌운 뒤, 이전 버전의 AOF, RDB 파일 삭제

    - 만약 `of-use-rdb-preamble`이 `no`로 생성되어 있으면, base 파일이 RDB가 아닌 AOF로 생성(`*.base.aof`)

  - AOF 파일의 재구성 과정은 모두 순차 입출력만 사용하기 때문에 디스크 접근하는 모든 과정이 효율적

#### 자동 AOF 재구성

```cmd
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

- 마지막으로 재구성 했던 파일 크기와 비교해 지정된 퍼센트 만큼 커졌을 때 재구성 시도
- 마지막 재구성 파일의 크기는 `INFO persistence` 커맨드로 확인할 수 있는 `aof_base_size` 값
- 데이터가 아무것도 없는 상태로 인스턴스가 처음 부팅되면 기존 사이즈는 0이기 때문에 `auto-aof-rewrite-min-size` 을 기준으로 데이터 재구성
- 사용자가 데이터를 생성하고 삭제하는 작업을 반복하여 `aof_base_size` 값이 작을 경우, 증가된 크기도 작음에도 불구하고 `auto-aof-rewrite-percentage` 설정을 초과하여 재구성이 될 경우 굉장히 비효율적
- `auto-aof-rewrite-min-size` 지정을 통해 재구성되는 최소 크기를 지정

#### 수동 AOF 재구성

- `BGREWRITEAOF` 명령어로 원하는 시점에 AOF 파일 재구성

#### AOF 타임스탬프

- `aof-timestamp-enabled`
- AOF 저장 시 타임스탬프 기록
- 타임스탬프를 사용하여 시스템상에서 시점 복원 가능
- `reds-check-aof`를 사용하여 원하는 시점으로 복원
- 타임스탬프 기능은 레디스 7.0 이후부터 지원
- 타임스탬프가 포함된 AOF 파일은 이전 버전에서 호환 안됨

#### AOF 파일 복원

- `redis-check-aof`를 사용하여 AOF 파일 손상 확인 가능
- 레디스에 장애가 발생할 경우, 쓰고 있던 AOF 파일에도 문제가 생길 수 있음
- 위 프로그램 실행은 비정상일 경우 복구 옵션 제공

#### AOF 파일의 안정성

- AOF 파일 저장 과정
  - `WRITE` 시스템 콜을 이용해 애플리케이션에서 파일 저장 신호를 OS로 보냄
  - 데이터는 커널 영역의 OS 버퍼에 임시 저장
  - OS는 커널에 여유가 생기거나 최대 지연 시간인 30초에 도달하면 데이터를 `FSYNC` 시스템 콜을 통해 내려씀
- `FSYNC`는 커널 부하에 관계 없이 데이터를 무조건 디스크에 플러시
  - `APPENDSYNC` 옵션을 사용하여 `FSYNC` 호출을 제어
    - `no`: AOF 파일을 저장할 때 `WRITE` 시스템 콜을 호출, 커널 영역에 데이터가 잘 저장되었는지만 확인하기 때문에 쓰기 성능이 가장 빠름
    - `always`: 항상 `WRITE`와 `FSYNC` 시스템 콜을 함께 호출, 데이터가 파일에 정확하게 저장되는 것을 기다리기 때문에 쓰기 성능 가장 나쁨
    - `everysec`: 데이터를 저장할 때 `WRITE` 시스템 콜 호출, 1초 마다 `FSYNC` 시스템 호출, 성능은 `no` 옵션과 거의 동일
    - `everysec` 옵션은 최대 1초의 데이터 유실이 발생하고, `no`의 경우 최대 30초의 유실이 발생하며, `always`의 경우 성능이 안좋아짐



#### 백업 시 유의 사항

- RDB와 AOF 파일을 사용할 경우 인스턴스의 `maxmemory` 값은 실제 서버 메모리보다 여유를 갖고 설정하는 것이 좋음
- `fork`를 통해 자식 프로세스에서 백업을 진행할 경우, 레디스는 `Copy-On-Write` 방식을 사용하여 데이터를 하나 더 복사
- 물리적 메모리에 있는 실제 메모리 페이지가 그대로 복제되기 때문에 최악의 경우 기존 메모리의 2배 사용할 수 있음
-  `maxmemory` 값을 너무 크게 설정할 경우, COW로 인해 OS 메모리가 가득 차는 상황 발생하여 OOM 문제로 서버가 다운될 수 있음
- RDB 파일을 만드는 과정에는 AOF 재구성을 할 수 없고, AOF 재구성 과정에는 RDB 파일을 만들 수 없음(`BGSAVE`) 