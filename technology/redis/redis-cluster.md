# 레디스 클러스터

- 운영 중인 상황에서 트래픽이 증가할 경우, 시스템 확장을 통해 증가된 트래픽에 대응할 수 있으며, 리소스를 투입하는 방식에 따라 **스케일 업**과 **스케일 아웃**으로 나뉨
- 스케일 업
  - 서버에 디스크, CPU, 메모리를 업그레이드 함으로써 서버 능력을 증강 시키는 수직 확장
- 스케일 아웃
  - 신규 장비를 추가해 시스템을 확장 시킴
  - 비슷한 사양의 서버를 추가로 연결해 처리량을 나눠 성능을 높임
  - 서버의 대수를 증가시키는 방식이기 때문에 수평 확장
- 일반적으로는 스케일 업 방식이 비교적 간단하고 비용이 적게 들지만 서버 성능을 업그레이드 하는데에는 한계 존재
- 스케일 아웃의 경우 서버를 추가하는 만큼 성능 확장이 가능하지만 **데이터가 여러 대의 서버에 분산** 처리돼야 하므로 **분산 처리 로직** 추가 개발 필요



## 레디스의 확장성

- 레디스 운영 도중 메모리 사용 용량 초과로 키 이빅션이 자주 발생하면, **메모리를 증가시키는 스케일 업**을 고려할 수 있음
  - 키의 이빅션은 `maxmemory`만큼 데이터가 저장되어 있을 경우 발생
  - 스케일 업을 통해 메모리를 증가시키고, `maxmemory` 값을 증가시킴으로써 문제 해결 시도
- 레디스는 싱글 스레드로 클라이언트의 커맨드가 수행되기 때문에 CPU 성능을 증가시키는 스케일 업은 의미 없음
- 데이터를 여러 서버로 분할해 관리하면 다수의 서버에서 요청을 병렬로 처리하기 때문에 처리량을 선형적으로 확장 가능



## 레디스 클러스터

![1](https://yqintl.alicdn.com/a0b317aa8dfb629a97d39e74fbc7c9e75dbe69ac.png)

- 클러스터 모드는 애플리케이션 아키텍처 변경 없이 레디스 인스턴스 간 수평 확장이 가능
- 데이터의 분산 처리, 복제, 자동 페일오버 기능 사용 가능



### 데이터 샤딩

- 데이터 저장소를 수평 확장하여 여러 서버에 데이터를 분할하는 데이터베이스 아키텍처 패턴

- 클러스터 기능을 통해 최대 1000개의 마스터 확장 가능

- 데이터는 키를 사용해 샤딩되며, 하나의 키는 하나의 마스터 노드에 매핑

- 클러스터 내 모든 노드는 특정 키가 저장되어야 할 노드를 알고 있음

  - 클라이언트는 클러스터 내 아무 노드에 데이터를 조회하거나 저장 시도해도, 요청을 받은 노드는 키가 매핑된 마스터 노드로 리다이렉트 할 수 있음
  - 위의 과정은 레디스 노드와 애플리케이션의 클라이언트에서 처리
  - 애플리케이션의 소스 코드 로직에서는 별도의 처리 필요 없음

- 클러스터에 노드가 추가/삭제되지 않는 이상 하나의 키는 특정 마스터에 매핑

  - 레디스 클라이언트는 클러스터 내 노드 변화가 없을 때, 특정 키를 관리하는 마스터 노드 정보를 캐싱하여 사용

- 클러스터는 최소 3대의 마스터와 3대의 레플리카 노드를 구성하는 것이 일반적

  - 클러스터 구성에 속한 각 노드는 서로를 모니터링
  - 마스터 노드에 장애가 발생할 경우, 다른 노드에서 마스터에 연결 되었던 레플리카 노드를 마스터로 자동 페일오버
  - 마스터에 연결된 잉여 레플리카 노드를 필요한 노드에 연결 시키는 레플리카 마이그레이션 작업을 수행

  

### 클러스터 통신

- 클러스터 내 노드는 **클러스터 버스**라는 독립적인 통신을 사용
- 모든 클러스터 노드는 다른 레디스 클러스터 노드에서 들어오는 연결을 수신하기 위한 TCP 포트를 열어놓음
- 클라이언트로부터 커맨드를 받는 TCP 포트와는 독립적으로 동작
- `cluster_bus_port` 설정을 정의하지 않으면 일반적으로 **클라이언트로부터 커맨드를 받는 TCP 포트에 10000을 더한 값**으로 자동 설정
- 클러스터는 모든 노드가 TCP 연결을 사용해 다른 모든 노드와 연결된 **풀 메쉬(full-mesh) 토폴로지**
  - N개의 클러스터 노드의 경우, 각 노드는 N-1개의 다른 노드와 연결
  - `PING`에 대한 `PONG` 응답이 늦으면 해당 노드로의 연결을 새로 시도
- **gossip protocol**와 **구성 업데이트 메커니즘**을 사용하여 클러스터가 정상적인 상태에서는 노드 간 너무 많은 메세지를 교환하지 않음



### 해시 슬롯을 이용한 데이터 샤딩

- 모든 데이터는 해시 슬롯에 저장
- 레디스는 총 **16,384**개의 해시 슬롯을 가짐
- 해시 슬롯은 또다른 key-value 저장소
- 키를 **CRC16**으로 암호화한 후 **16,384**로 나눈 나머지 값을 이용해 해시 슬롯이 결정
- 해시 슬롯 값이 결정되면, 클러스터 노드 수 범위로 할당된 해시 슬롯에서 해당 키를 조회하거나 저장
- 해시 슬롯은 마스터 노드 내에서 자유롭게 옮길 수 있으며, 옮기는 과정에서 데이터에는 정상적으로 접근 가능
- 마스터 노드를 신규로 추가할 경우, 마스터 노드 추가 후 기존 마스터 노드에 할당된 해시 슬롯 일부를 새로 추가한 마스터 노드로 이동
- 마스터 노드를 삭제할 경우, 삭제할 노드가 가지고 있는 해시 슬롯을 전부 다른 마스터로 이동 후 해당 노드를 삭제



### 해시 태그

- 클러스터를 사용할 경우, 키 마다 관리되는 노드가 다르기 때문에 `MGET`과 같은 다중 키 커맨드를 사용할 수 없음

  - 정확하게는 사용 불가능 한 것이 아니라 `MGET` 명령어로 찾은 키들이 서로 다른 노드에 존재할 경우 처리 불가

- **해시 태그** 기능을 사용하여 특정 키가 저장될 해시 슬롯을 지정할 수 있음

  `user:{123}:profile`, `user:{123}:account`

  - 대괄호가 키에 여러번 등장할 경우, 처음 '{'부터 처음 만나는 '}' 이전 문자까지 해싱

    `user{}id -> user{}id`, `user{{name}}id -> {name`

- 해시 태그를 사용하면 해시 태그 값이 같은 키는 동일한 마스터 노드에 저장되기 때문에 `MGET` 커맨드를 사용할 수 있지만, 해시 태그를 많이 사용할 경우 **특정 마스터 노드에 데이터가 몰리는 현상** 발생



### 자동 재구성

- 센티널 모드의 경우 고가용성을 위한 자동 페일오버를 위해 센티널 인스턴스를 별도로 구성해서 레디스 노드를 감시하는 구조

- 클라스터 모드는 모든 노드가 서로를 감시

- 모든 노드는 **클러스터 버스**를 통해 통신하며, 일부 노드에 문제가 생겼을 경우 자동으로 클러스터 구조를 재구성

- 자동 재구성

  - 마스터 노드에 장애가 발생하여 레플리카 노드를 마스터로 승격 시키는 자동 페일오버
  - 잉여 레플리카 노드를 다른 마스터에 연결시키는 레플리카 마이그레이션

- 마스터 노드에 장애가 발생할 경우, 레플리카 노드가 다른 마스터 노드들에게 페일오버를 시도해도 될지 투표를 요청

  ![CLUSTER Failover](https://redisgate.kr/images/cluster/cluster_master_down_2.png)

  - 투표 요청을 받은 마스터 노드들은 기존 마스터 노드에 문제가 있는지 판단
  - 문제가 있을 경우, 레플리카에 투표
  - 과반수 이상의 마스터 노드가 투표를 받으면 해당 레플리카 노드가 마스터로 승격
  - `cluster-require-full-coverage` 설정이 되어 있을 경우, 승격한 마스터 노드에 장애가 다시 발생하면 전체 클러스터 사용 중단
  - 일부 마스터 노드에 장애가 발생하고 더이상 페일오버할 레플리카 노드가 없을 경우, 일부 해시 슬롯에 접근할 수 없는 상황이 발생하기 때문에 데이터 정합성을 위해 클러스터 전체 상태가 `fail` 처리되어 데이터 조작 실패
  - 다운타임을 줄이기 위해서는 레플리카 마이그레이션을 사용하도록 설정하고, 아무 마스터 노드에 복제본을 하나 추가하여 레플리카 마이그레이션이 일어나도록 함



### 자동 레플리카 마이그레이션

![11.png](https://image.toast.com/aaaadh/real/2020/techblog/11%282%29.png)

- 레디스 클러스터는 각 마스터 노드에 연결된 레플리카 노드의 불균형을 파악해 레플리카를 필요한 마스터 노드로 연결 시킴
- 레플리카 마이그레이션은 모든 마스터가 적어도 1개 이상의 레플리카에 의해 복제되는 것을 보장
- 가장 많은 수의 레플리카가 연결된 마스터 노드의 레플리카 아래의 기준을 만족하는 노드 하나를 옮김
  - 레플리카의 상태가 `fail`이 아님
  - 노드 ID가 가장 작은 작음
- `cluster-allow-replica-migration = yes`
- `cluster-migration-barrier` 옵션은 레플리카를 마이그레이션 하기 전 마스터가 가지고 있어야 할 최소 레플리카 수 설정
  - 만약 위 값이 2로 설정되어 있으면, 레플리카 수 불균형이 존재하더라도 2개를 초과한 마스터가 없을 경우 마이그레이션이 진행 안됨



## 레디스 클러스터 실행

- `cluster-enabled true`로 클러스터 모드 설정

- `redis-cli -cluster create [host:port] --cluster-replicas 1`

  - 각 마스터 마다 1개의 레플리카를 추가하는 클러스터를 생성

- 클러스터를 생성하면, 해시 슬롯이 할당되며 해시 슬롯은 마스터 노드에만 할당

- 해시 슬롯 내부의 데이터가 레플리카에 저장되기는 하지만 해시 슬롯을 할당하지는 않음

- CLUSTER NODES

  | 필드               | 예시                   | 설명                                                         |
  | ------------------ | ---------------------- | ------------------------------------------------------------ |
  | **Node ID**        | `07c37dfe...`          | 노드를 고유하게 식별하는 40자리 해시 ID                      |
  | **주소**           | `127.0.0.1:7002@17002` | 클러스터 노드 통신용 주소와 포트 <br> (`@cport`은 클러스터 내부 통신용 포트, 보통 client 포트+10000) |
  | **Flags**          | `master`               | 노드 역할/상태 <br>- `myself`: 현재 접속한 노드 <br>- `master`: 마스터 노드 <br>- `slave`: 레플리카 노드 <br>- `handshake`: 합류 중 <br>- `fail?`: 장애 의심 <br>- `fail`: 장애 확정 |
  | **Master Node ID** | `-`                    | 레플리카일 경우, 복제 대상 마스터의 Node ID <br>마스터인 경우 `-` |
  | **Ping-sent**      | `0`                    | 마지막으로 PING을 보낸 시점 (밀리초 타임스탬프) <br>0이면 없음 |
  | **Pong-recv**      | `1426238317239`        | 마지막으로 PONG을 받은 시점 (밀리초 타임스탬프)              |
  | **Config-epoch**   | `2`                    | 현재 노드의 구성 에포크, 페일오버가 발생할 때마다 에포크는 증가<br>구성 충돌이 있을 때 에포크가 높은 노드의 구성으로 변경 |
  | **Link state**     | `connected`            | 해당 노드와의 클러스터 연결 상태 <br>`connected` 또는 `disconnected` |
  | **Slots**          | `5461-10922`           | 이 노드가 담당하는 해시 슬롯 범위 <br>마스터만 가짐, 레플리카는 비어있음 |

- 레디스 클라이언트는 특정 키를 관리하는 클러스터 노드로 리다이렉트 될 경우, 해당 키에 대한 매핑 테이블을 만들어 정보를 캐싱하며, 마스터 노드 추가/삭제, 페일오버 발생 등 클러스터의 구조가 변경되면 매핑 테이블을 리플레시
- 커맨드에 의한 수동 페일오버
  - 기존 마스터에 연결된 클라이언트는 잠시 블락
  - 페일오버를 시작하기 전 복제 딜레이를 기다림
  - 마스터의 복제 오프셋을 레플리카가 따라잡는 작업이 완료되면 페일오버 시작
  - 페일오버가 완료되면 클러스터의 정보를 변경
  - 모든 작업이 완료되면 클라이언트는 새로운 마스터로 리다이렉트
- 장애에 의한 자동 페일오버
  - `cluster-node-timeout` 시간 동안 마스터에서 응답이 오지 않으면 마스터의 상태가 정상적이지 않다고 판단하여 페일오버 트리거 (기본값 15초)



## 클러스터 운영

### 클러스터 리샤딩

- 마스터 노드가 가지고 있는 해시 슬롯 중 일부를 다른 마스터로 이동 시키는 것

- `redis-cli --cluster reshard <ip> <port>`

  - 커맨드를 실행하고, 이동시킬 슬롯 개수를 지정
  - 해시 슬롯을 받을 클러스터 노드 ID를 입력
  - 해시 슬롯을 제공할 클러스터 노드 ID를 입력 (all을 입력할 경우 모든 노드에서 조금씩 지정한 마스터로 이동)

- 한번의 커맨드로 리샤딩

  ```cmd
  redis-cli --cluster reshard 127.0.0.1:7000 \
    --cluster-from source-node-id \
    --cluster-to target-node-id \
    --cluster-slots 500 \
    --cluster-yes
  ```



### 클러스터 확장-신규 노드 추가

- 클러스터 신규 노드 추가를 위한 선행 조건
  - 마스터 노드 추가와 레플리카 추가 모두 레디스에 데이터가 저장되어 있지 않은 상태여야 추가 가능
  - `redis.conf`에 `cluster-enabled yes`로 설정되어 있어야 함
- `redis-cli --cluster add-node {new_host}:{new_port} {existing_host}:{existing_port}`
  - 마스터로 노드를 추가
  - 마스터로 추가하더라도 해시 슬롯이 할당되지 않은 상태이기 때문에 리샤딩을 통해 해시 슬롯 할당 필요
- `redis-cli --cluster add-node {new_host}:{new_port} {existing_host}:{existing_port} --cluster-slave [--cluster-master-id <기존 마스터 ID>]`
  - 레플리카를 추가
  - 추가될 마스터 노드를 지정하지 않으면 임의의 마스터에 레플리카가 추가
- `redis-cli --cluster del-node {host}:{port} {node_id}`
  - 마스터 여부에 관계 없이 삭제 가능
  - 마스터를 삭제할 경우 마스터에 데이터가 없는 상태일 때 삭제 가능
    - 마스터를 삭제하기 위해서는 기존에 할당된 해시 슬롯을 전부 다른 마스터로 옮겨야 삭제 가능
    - 해시 슬롯 이동 없이 수동 페일오버를 진행하여 레플리카로 만든 후 삭제도 가능
- 노드를 삭제하기 위해서는 제거할 노드의 클러스터 구성 데이터를 지우는 것 뿐만 아니라 클러스터 내 다른 노드에서도 해당 노드를 지우는 커맨드 실행 필요
  - `CLUSTER FORGET <node_id>`
    - 위 커맨드를 수신한 노드는 노드 테이블에서 삭제할 노드의 정보를 지움
    - 가십 프로토콜을 사용해서 신규 노드를 자동으로 감지하고 새로운 노드로 추가할 수 있기 때문에 커맨드를 실행하여 60초 동안 삭제할 노드 ID를 가지고 있는 노드와 신규로 연결되지 않도록 설정 필요
- 클러스터 노드의 클러스터 이력, 메타 데이터를 전부 지우고 초기 상태로 되돌리는 작업 (테스트 중 노드 초기화/재활용 등)
  - `CLUSTER RESET [HARD|SOFT]`
    - 클러스터에서 레플리카 역할이었다면 노드를 마스터로 전환하고 노드가 가지고 있던 데이터셋은 전부 삭제, 노드가 마스터이고 저장된 키가 있다면 리셋 작업은 중지 (HARD/SOFT)
    - 노드가 해시 슬롯을 가지고 있었다면 모든 슬롯은 해제, 만약 페일오버가 진행되는 과정있더마녀 페일오버에 대한 진행 상태도 초기화 (HARD/SOFT)
    - 클러스터 구성 내의 다른 노드 데이터가 초기화, 기존 클러스터 버스를 통해 연결 됐던 노드를 더 이상 인식 불가 (HARD/SOFT)
    - `currentEpoch`, `configEpoch`, `lastVoteEpoch` 값이 0으로 초기화 (HARD)
    - 노드 ID를 새로운 임의의 ID로 변경 (HARD)



### 레디스 클러스터로의 데이터 마이그레이션

- 다중 키 커맨드를 사용하지 않는 경우, 레디스 클라이언트와 레디스 간 커넥션 변경 외에 데이터 저장 로직은 문제 발생하지 않음
- 다중 키 커맨드를 사용했을 경우, **해시 태그**를 사용하도록 애플리케이션 로직 일부 수정 필요
- 데이터를 받을 클러스터는 해시 슬롯 할당까지 완료된 상태여야 하고, 클러스터 내 모든 마스터 노드에 접근 가능 상태여야 함
- 소스 레디스에 연결된 클라이언트는 모두 중단시키는 것이 좋음
  - 마이그레이션 도중 소스 레디스에 변경된 데이터는 마이그레이션 되는 클러스터에 반영되지 않음



### 레플리카를 이용한 읽기 성능 향상

- 레디스 클라이언트는 기본적으로 키를 갖고 있는 마스터 노드에 연결을 리다이렉션하고, 레플리카로 접근할 경우 우선 마스터로 연결이 변경됨
- 읽기 성능을 위해 레플리카를 읽기 전용 노드로 사용할 경우, `READONLY` 모드로 클라이언트를 변경하고 레플리카 노드에서 데이터를 직접 읽어올 수 있음



## 레디스 클러스터 동작

### 하트비트 패킷

- 레디스 클러스터 노드들은 서로의 상태를 확인하기 위해 지속적으로 `PING`, `PONG` 패킷을 주고 받음
- 하트비트 패킷에는 패킷을 발신하는 노드가 알고 있는 클러스터 내 다른 노드 정보를 나타내는 **가십 섹션** 포함
- 하트비트 패킷을 받은 노드는 다른 노드 정보를 알 수 있음
- 노드 간 구성 정보의 정합성을 유지하기 위해 에포크를 활용
  - 수신 받은 패킷의 에포크 값이 로컬 노드의 값보다 크면 패킷을 송신한 노드의 에포크 값으로 업데이트
  - 노드 간 하트비트 패킷을 주고 받으면서 클러스터에서 가장 큰 구성 에포크 값(가장 최신 값)으로 통일



### 해시 슬롯 구성 전파

- 해시 슬롯 구성은 두가지 방법으로 전파
  - 하트비트 패킷을 `PING`, `PONG`으로 보낼 때 항상 자기가 갖고 있는 해시 슬롯을 패킷 데이터에 추가
  - 하트비트 패킷에 포함된 구성 에포크 값을 확인하여 패킷을 발신한 노드의 에포크 값이 오래된 경우(값이 작은 경우) 오래된 값을 수신한 노드는 신규 에포크의 구성 정보를 포함한 **업데이트 메세지**를 발신 노드에 보내 해시 슬롯 구성을 업데이트 하도록 유도
- 초기 클러스터 생성 시 모든 노드의 해시 슬롯은 NULL로 초기화
- 두가지 해시 슬롯 전파 방법을 사용해 특정 해시 슬롯을 가지고 있다는 메세지를 받으면서 자신의 해시 슬롯 구성 정보를 업데이트
- 에포크 값 3을 가진 노드가 해시 슬롯 1,2를 가지고 있다고 주장하면, 해시 슬롯 테이블을 업데이트
  - 에포크 값 4를 가진 노드가 해시 슬롯 1,2를 다른 노드가 가지고 있다고 주장하면, 기존 에포크 값보다 크기 때문에 해당 정보로 해시 슬롯 테이블을 업데이트
- 해시 슬롯 구성의 변경은 페일오버나 리샤딩 중에만 발생하고, 두 작업은 모두 에포크를 증가시키는 작업이기 때문에 작업 이후 변경 사항을 위의 방법을 통해 전파
- 클러스터 노드는 가장 큰 구성 에포크 값을 가진 노드에 동의하는 구조로 되어 있어 에포크 값이 큰 해시 슬롯 구성 정보로 업데이트 가능



### 노드 핸드셰이크

- 노드가 클러스터 합류하기 위해서는 `CLUSTER MEET` 커맨드를 다른 노드로 보냄
- 해당 커맨드를 수신한 노드는 자신이 알고 있는 다른 노드로 노드 합류 정보를 전파
- 신규로 합류할 노드 정보를 모르는 노드가 합류 정보를 전파 받을 경우, 신규 노드와 `CLUSTER MEET`을 사용하여 신규 연결
- 만약 신규로 합류할 노드를 알고 있다면 합류 정보를 무시
- 위의 방법을 사용하여 풀 메쉬 연결 진행
- `CLUSTER MEET`은 방향성이 없기 때문에 한번만 진행
- 이미 알고 있는 노드 간에만 통신을 주고 받기 때문에 다른 클러스터와 연결 상황을 막을 수 있음



### 클러스터 라이브 재구성

- 해시 슬롯은 논리적인 키의 집합이기 때문에 해시 슬롯을 옮기는 것은 실제로 데이터를 옮기는 것
- `CLUSTER SETSLOT <slot> MIGRATING <targetNodeId>`: 특정 노드에 옮길 슬롯을 지정하여 이동
  - 커맨드를 실행하는 중 클라이언트으로부터 데이터 조회 요청을 받을 경우, 기존에 존재한 키는 슬롯을 주고 있는 노드에서 읽음
  - 옮기는 슬롯에 새로운 키를 생성하는 커맨드의 경우 슬롯을 받고 있는 노드에서 수행
- `CLUSTER SETSLOT <slot> NODE <nodeId>`: 이동 시킨 해시 슬롯에 대한 소유권 변경 정보를 전파



### 리다이렉션

- `MOVED`
  - 요청하는 해시 슬롯를 관리하는 노드를 알려주는 신호
- `ASK`
  - 현재 요청한 커맨드를 수행할 수 있는 노드를 알려주지만, 다음 요청은 자신에게 보내라는 신호
  - 해시 슬롯을 이동하는 과정에서만 발생
    - 리다이렉션 오류를 반환한 노드 정보로 쿼리를 재전송
    - 같은 키에 대한 쿼리가 다시 들어오면 리다이렉션된 노드가 아닌 기존 노드로 쿼리를 다시 보냄
    - 리다이렉션 받은 값으로 클라이언트의 해시 슬롯 맵을 업데이트 하지 않음



### 장애 감지 페일오버

- `PFAIL`
  - 특정 노드에 타임아웃 시간 이상 도달할 수 없는 경우
    - 해당 노드에 `PING` 패킷을 보냈지만 `NODE_TIMEOUT` 시간 이상이 지나도 `PONG`을 받지 못한 상태
    - `NODE_TIMEOUT` 시간은 노드 간 왕복 시간 (RTT)보다 항상 커야 함
    - `PING`을 보낸 후 설정된 타임아웃 절반 시간 동안 `PONG`을 받지 못했을 때 `PING`을 다시 보냄
  - 마스터, 레플리카 상관 없이 클러스터 내 모든 노드들은 다른 노드를 `PFAIL`로 변경할 수 있음
- `FAIL`
  - 마스터 노드에 페일오버를 트리거 하기 위해서는 해당 노드의 플래그가 `FAIL`이여야 함
  - A 노드가 B 노드를 `PFAIL`로 플래깅 했을 경우, 클러스터 내 다른 노드가 보낸 하트비트 패킷에서 B의 상태에 대한 정보를 들음
  - 일정 시간 내 다른 노드에서 B에 대한 `PFAIL` 또는 `FAIL` 알림을 받으면 해당 노드를 `FAIL`로 플래깅



### 마스터 선출

- 레플리카는 아래의 조건일 때 페일오버를 직접 시도

  - 마스터가 `FAIL` 상태
  - 마스터가 1개 이상의 해시 슬롯을 가지고 있음
  - 마스터와의 복제가 끊어진 지 오래됨

- 위 조건을 만족하면 레플리카는 마스터로 선출되기 위해 자신의 에포크를 하나 증가 시키고 마스터 인스턴스에 투표 요청

  - `FAILOVER_AUTH_REQUEST` 패킷을 보내 투표 요청
  - 요청 받은 마스터는 `FAILOVER_AUTH_ACK` 패킷으로 투표에 동의함을 응답
  - 마스터는 `NODE_TIMEOUT * 2` 시간 동안 마스터로 승격하고자 하는 다른 레플리카에 투표할 수 없음
  - 레플리카는 자신의 현재 에포크 값보다 작은 `FAILOVER_AUTH_ACK` 패킷은 무시
  - 다수의 마스터로부터 ACK를 받은 레플리카가 마스터 후보로 선출
  - `NODE_TIMEOUT * 2` 시간 동안 과반수 이상 마스터에서 ACK가 오지 않으면 페일오버 중단
  - `NODE_TIMEOUT * 4` 만큼의 지연 후 다시 새로운 투표 시도
  - `DELAY = 500ms + 랜덤 지연 시간 (0 ~ 500ms) + SLAVE_RANK * 1000ms`
    - 마스터가 `FAIL` 상태가 된 이후 레플리카가 투표를 시작할 때까지 딜레이 시간
    - 랜덤한 지연 시간을 이용해 같은 마스터에 연결된 여러 레플리카에서 동시에 투표 시작하는 것을 방지
    - `SLAVE_RANK`는 마스터에서 복제한 데이터의 양과 관련된 우선순위
      - 레플리카끼리 메세지를 교환하며, 가장 최근의 오프셋을 가진 레플리카가 0순위, 그 다음이 1순위 등으로 우선순위 부여

  ![img](https://miro.medium.com/v2/resize:fit:1400/1*XJQbMYsei5OhgwCOu4Ju8A.png)