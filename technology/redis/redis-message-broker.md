# 레디스 메세지 브로커

- 예기치 못한 장애로 인해 통신이 안될 경우, 당장 메세지를 처리하지 못하더라도 보낸 메세지를 어딘가에 쌓아 둔 뒤 나중에 처리할 수 있는 채널을 만들어주는 비동기 통신을 사용하는 것이 권장
- 메세지 브로커
  - 메세징 큐에서는 데이터를 생성하는 **생산자**와 데이터를 수신하는 **소비자**로 나뉨
  - 이벤트 스트림에서는 데이터를 생성하는 **발행자**와 데이터를 조회하는 **구독자**로 나뉨
  - 메세징 큐와 이벤트 스트림 차이
    - 방향성
      - 메세징 큐의 생산자는 소비자의 큐로 데이터를 **푸시**
      - 스트림의 발행자는 스트림의 특정 저장소에 하나의 메세지를 보내고, 소비자들이 스트림에서 같은 메세지를 **풀** (메세지 복제 저장하지 않음)
    - 영속성
      - 메세징 큐는 소비자가 메세지를 읽어갈 때 큐에서 데이터를 삭제
      - 이벤트 스트림에서는 데이터를 바로 삭제하지 않고, 저장소의 설정에 따라 특정 기간 동안 보관
    - 메세징 큐는 일대일에 유용
    - 이벤트 스트림은 다대다에 유용



## pub/sub

- 발행자가 특정한 채널에 데이터를 전송
- 채널을 리스닝 하는 모든 소비자는 데이터를 바로 소비
- 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제되는 **일회성**
- 메세지가 잘 전달되었는지 정보는 보장하지 않는 **fire-and-forget** 패턴
  - **fire-and-forget**은 성능 향상이나 비동기 작업을 수행할 때 사용하며, 작업 완료나 결과에 대한 처리가 필요하지 않을 때 유용
  - 신뢰성이 필요한 작업에는 적합하지 않음
- 레디스 노드에 접근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있음
- 발행자는 어떤 구독자가 메세지를 읽어갔는지와 정상적으로 모든 구독자에게 메세지가 전달되었는지 확인할 수 없음
- 구독자는 메세지가 언제 어떤 발행자에 의해 생성되었는지 등의 메타데이터를 알 수 없음
- `PUBLISH`를 통해 메세지를 발행
- `SUBSCRIBE`를 통해 메세지를 구독
- 클라이언트가 구독자로 동작할 때에는 새로운 채널을 구독할 수는 있지만 **pub/sub 외 다른 커맨드 실행 불가**
- `PSUBSCRIBE` 커맨드를 사용하여 와일드 카드 패턴으로 구독을 할 수 있으며, 이 경우 메세지 타입이 `pmessage` 타입으로 들어옴
  - 만약 `SUBSCRIBE`와 `PSUBSCRIBE`로 한 채널을 모두 구독하는 형태라면, 해당 채널 메세지가 두 번 수신(`message`, `pmessage`)

#### 클러스터 구조 pub/sub

- 클러스터 구조의 레디스의 경우, 메세지를 발행하면 클러스터에 속한 모든 노드에 자동 전달
- 클러스터의 아무 노드에 연결해 메세지 수신 가능
- 기존 클러스터 구조에서 데이터 저장 방법(샤딩)과 달리 모든 노드에 메세지가 중복 저장되기 때문에 비효율적 방식
- **sharded pub/sub**의 도입으로 특정 채널을 담당하는 노드가 할당되고, 해당 노드에서만 메세지를 발행하고, 구독하는게 가능 (일반적인 클러스터와 동일하게 슬롯을 가지고 있지 않은 노드는 해당 채널 슬롯이 할당된 노드로 리다이렉트 메세지 반환)



## 레디스 list를 메세징 큐로 사용

- `LPUSH`, `LPOP`, `RPUSH`, `RPOP`을 사용하여 큐로 사용
- 트위터의 경우 `RPUSHX`를 사용하여 유저 타임라인을 만들고 있으며, 'X' 커맨드를 사용하여 이미 유저 타임라인에 대한 키가 존재할 때에만 해당 데이터를 타임라인에 푸시함으로써 장기간 접속하지 않은 사용자의 타임라인에는 데이터를 추가하지 않음
- `BRPOP`, `BLPOP`을 사용하여, 데이터가 들어올 때까지 블록킹 상태로 대기할 수 있음
  - 여러 클라이언트가 동시에 대기할 경우, 리스트에 데이터가 입력되었을 때 가장 먼저 요청을 보낸 클라이언트가 데이터를 가져감
  - 일반 리스트 반환과 다르게 팝된 리스트의 키와 팝된 리스트의 값 두 개의 데이터를 반환하여, 클라이언트가 여러 개의 리스트에 대기할 수 있도록 설계



## 레디스 스트림

- 데이터를 게속 추가하는 방식으로 저장하는 **append-only**

- 용도

  - 대량의 데이터를 효율적으로 처리하는 플랫폼
  - 여러 생성자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터 저장소 및 중간 큐잉 시스템

- 레디스에서 스트림은 하나의 자료 구조이며, 다른 자료 구조와 동일하게 하나의 키를 가짐

- 카프카의 경우 메세지를 식별하는 오프셋은 토픽 내 파티션에서만 유니크한 값을 가짐

- 레디스 스트림의 경우, 각 메세지는 시간과 관련된 유니크한 ID를 가지며, ID는 중복되지 않음

  - `<millisecondsTime>-<sequenceNumber>`

  - 시간 파트는 데이터가 저장될 시점의 레디스 노드 로컬 시간
  - 시퀀스 파트는 같은 시간에 저장된 64bit로 된 데이터의 순서
  - ID는 시간 값을 가지기 때문에 특정 데이터를 검색 가능

- 레디스 스트림의 경우 별도의 스트림 생성 과정 없이 `XADD <stream> <ID> <field key> <field value>`로 커맨드를 수행할 경우, 생성된 스트림이 없으면 스트림을 생성하고, 스트림이 이미 생성되어 있으면 기존 스트림에 데이터를 추가

  - <ID> 에 `*` 값을 주면, 타임스탬프로 이뤄진 ID로 스트림 데이터를 생성, `<숫자>-<숫자>` 형식으로 지정할 수는 있으나, 만약 임의로 ID를 지정할 경우, 이전에 저장된 값보다 작은 값을 지정할 수는 없음
  - 스트림의 데이터는 hash 자료구조와 비슷하게 key-value 쌍으로 저장

-  `XREAD [COUNT n] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]`

  - 실시간으로 key 스트림의 데이터를 읽어오는 커맨드
  - `BLOCK 0`의 경우, 읽어올 데이터가 없더라도 연결을 끊지 않고 게속 리스닝

- `XRANGE`, `XREVRANGE`를 사용하면 특정 ID(시간대)의 데이터를 읽어올 수 있음

  - 위 명령어의 경우 한번 실행된 뒤 종료

### 소비자/소비자 그룹

-  **fan-out**: 같은 데이터를 여러 소비자에게 전달하는 것
- 레디스 스트림은 카프카와 동일하게 여러 소비자가 동일한 메세지를 `XREAD` 명령어를 통해 읽어갈 수 있음
- 레디스 스트림은 데이터가 저장될 때 고유한 ID를 부여받아 순서대로 저장되기 때문에 소비자에게 전달될 때 순서가 항상 보장
- 카프카의 경우 파티션 내에서만 순서가 보장되기 때문에 소비자가 여러 파티션에서 메세지를 읽어갈 때에는 순서가 보장되지 않음

##### 소비자 그룹

- 한 소비자 그룹 내 소비자들은 다른 소비자가 아직 읽지 않은 데이터만을 읽을 수 있음
- 따라서 메세지가 저장된 순서대로 소비자에서 메세지가 처리 (메세지가 소비자들에게 전달되는 순서가 메세지가 저장된 순서와 일치하는 것이지 순서대로 완료된다는 것은 아님)
- `XGROUP CREATE mystream mygroup $ MKSTREAM`: 소비자 그룹 생성
- `XREADGROUP GROUP mygroup consumer-id BLOCK 0 COUNT 10 STREAMS mystream >`: 그룹 단위 메세지 소비
  - 소비자 마다 식별할 수 있는 `consumer-id`를 지정
  - `>` 옵션의 경우, 다른 소비자가 읽지 않은 메세지를 가져오는 것이고, 만약 `0` 또는 `숫자 ID`를 지정할 경우, 입력한 ID보다 큰 ID 중 대기(pending list)에 속하던 메세지를 반환
  - 소비자는 별도의 소비자 생성 없이 메세지를 가져올 수 있지만 소비자 그룹으로 메세지를 가져오기 위해서는 소비자 그룹을 생성한 이후에 생성된 소비자 그룹을 지정하여 메세지를 가져올 수 있음
- 카프카는 파티션으로 부하를 분산시키는 반면, 레디스는 소비자 그룹을 통해 메세지를 분산
- 레디스의 소비자 그룹은 카프카와 동일하게 소비자 그룹 간 메세지 중복 소비 가능
- 하나의 소비자 그룹이 여러 스트림을 리스닝 하는 것도 카프카와 동일하게 가능

##### ACK와 보류 리스트

- 각 소비자에게 어떤 메세지가 전달 되었고, 전달된 메세지의 처리 유무를 파악해야 함
- 레디스 스트림은 소비자 그룹 내 소비자가 메세지를 읽어갈 경우, 각 소비자 별 읽어간 메세지에 대한 리스트를 새로 생성
- 마지막으로 읽어간 데이터의 ID로 `last_delivered_id` 값을 업데이트
- `last_delivered_id`으로 소비자 그룹에 마지막으로 전달된 ID를 추적하여 소비자 그룹 내 중복 소비 방지
- 메세지가 소비자에게 전달될 경우, 각 소비자 별 pending list에 가져간 메세지를 기록
- 소비자가 메세지 처리 완료 ACK를 레디스로 전송하면, pending list에서 ACK를 받은 메세지를 삭제
- `XREADGROUP`으로 데이터를 읽어온 후 `XACK`를 주기적으로 보내 메세지 처리 완료를 알려야 함

##### 메세지 재할당

- pending list에 남아 있는 소비자의 메세지가 처리되지 못하고 계속 대기할 경우 해당 메세지를 다른 소비자가 대신 처리
- `XCLAIM key group consumer min-idle-time id [id ...] [options]`
  - 특정 소비자의 pending list에 있는 메세지가 `min-idle-time` 동안 처리가 되지 않을 때 메세지 재할당

##### 자동 메세지 재할당

- `XAUTOCLAIM key group consumer min-idle-time start [COUNT n] [JUSTID]`
- 지정한 소비자 그룹에서 최소 대기 시간을 만족하는 보류 중인 메세지가 있다면 지정한 소비자에게 자동 재할당