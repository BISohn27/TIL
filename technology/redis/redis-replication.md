# Redis Replication

## 가용성

- 일정 기간 동안 서비스를 정상적으로 사용할 수 있는 시간 비율
- 가용성이 높은 시스템을 **고가용성(HA)**이라 함



## 레디스의 고가용성

- 복제: 마스터 노드의 데이터를 Replica로 실시간 복사 (복제)
- 자동 failover: 마스터 노드에 발생한 장애를 감지, 클라이언트의 요청을 자동으로 복제본 노드에 리다이렉트 (센티널)



## 왜 데이터베이스는 복제를 사용하는가?

- 애플리케이션을 실행 중인 하드웨어는 언제든 고장 날 수 있음

  -> 안정적 운영을 위해서는 마스터 데이터베이스가 다운 되었을 때 대신 사용할 여분의 레플리카 필요

- 대규모 서비스에서 마스터 노드로 부하가 가중되는 문제

  -> 일부 트래픽을 레플리카에서 처리함으로써 마스터 노드의 부하를 분산

- 마스터 노드에서 매번 데이터를 백업하는 것은 부담스러운 작업

  -> 백업을 레플리카에서 수행함으로써 백업 작업이 서비스에 미치는 영향도를 줄임

- MySQL이나 PostgreSQL은 멀티 마스터 복제 구조로 모든 노드가 마스터이면서 레플라카
- 레디스는 마스터는 하나, 레플리카는 기본적으로 읽기 전용 복제이기 때문에 모든 쓰기 요청은 마스터에서 처리



## 복제 구조 구성

![1.png](https://image.toast.com/aaaadh/real/2020/techblog/1%2811%29.png)

```cmd
REPLICAOF <master-ip> <master-port>
```

- 데이터 업데이트는 마스터 노드에서 이뤄지기 때문에 애플리케이션은 마스터 노드에 연결해야 함
- 마스터에 문제가 생겼을 경우에는 레플리카로 연결 설정
- 복제 연결은 마스터 노드에 연결할 수도 있고, 마스터에 연결된 레플리카에 복제 연결을 할 수도 있음
- 하지만 한 개의 복제 그룹에는 하나의 마스터만 존재
- 하위 레플리카는 모두 읽기 전용
- 마스터 노드에 패스워드가 설정되어 있을 경우 `masterauth <password>` 설정 적용 필요 (ACL인 경우에는 ACL 적용)



## 복제 메커니즘

### 동기 방식 복제 연결

- 로컬 디스크 RDB 파일을 사용한 복제 (`repo-diskless-sync no`)

  ![Full Sync Disk-Disk](https://redisgate.kr/images/server/full_sync_disk_disk.png)

  - 복제 과정

    1. REPLICAOF 커맨드로 복제 연결 시도

    2. 마스터 노드에서 fork로 자식 프로세스를 생성하여 RDB 스냅샷 파일 생성

    3. RDB 파일 이후 변경 내역은 레디스 프로토콜로 마스터 노드 복제 버퍼에 저장

    4. RDB 파일 생성이 완료되면 레플리카 노드에 전송

    5. 레플리카 노드는 저장되었던 모든 데이터를 삭제하고 RDB 파일로 데이터 로딩

    6. RDB 파일 생성 과정에 발생한 마스터 노드 변경 내역은 레디스 프로토콜이 저장된 복제 버퍼를 전달

  - RDB 파일을 로컬 디스크에 저장한 후 복제를 하는 방식은 디스크를 사용하기 때문에 I/O 처리량에 영향을 받음

    - 마스터 노드에서 RDB 파일을 쓰는 과정, 레플리카 노드에서 RDB 파일을 읽어오는 과정 모두 디스크 I/O
    - NAS와 같이 로컬 디스크 I/O 속도보다 느린 경우 복제 속도는 더 느려짐



- 디스크를 사용하지 않는 복제 (`repo-diskless-sync yes`)
  	![Full Sync Memory-Disk](https://redisgate.kr/images/server/full_sync_mem_disk.png)
  - 과정
    1. REPLICAOF 커맨드로 복제 연결 시도
    2. 마스터 노드는 소켓 통신을 사용해 레플리카 노드에 바로 연결
    3. RDB 데이터는 메모리 상에서 생성됨과 동시에 점진적으로 레플리카와 연결된 소켓을 통해 전송
    4. RDB 데이터 생성 과정에서 발생한 데이터 변경 내역은 레디스 프로토콜 형태로 복제 버퍼에 저장
    5. 레플리카는 소켓에서 읽어온 RDB 데이터를 로컬 디스크에 RDB 파일로 저장 (`repl-diskless-load disabled`)
    6. 레플리카에 저장된 모든 데이터를 삭제하고, 저장된 RDB 파일로 데이터를 로드
    7. 마스터 노드는 복제 버퍼에 저장된 변경 내역을 레플리카 노드에 전송
  - `repl-diskless-load disabled`로 설정하면 RDB 데이터를 바로 레플리카 노드에 로드하지 않고 로컬 디스크에 저장
    - 레플리카 노드는 가져온 데이터를 로드하기 전에 자신이 가지고 있는 데이터를 삭제해야 함
    - 소켓으로 받아온 RDB 데이터가 정상적인지 미리 확인 불가
    - 기존에 저장된 데이터를 삭제하기 전에 받아온 RDB 데이터를 우선 로컬 디스크에 저장함으로써 데이터 안정성 확보 가능
  - 디스크 I/O가 느리고, 네트워크가 빠른 경우 디스크를 사용하지 않는 복제 방식을 사용하는 것이 더 빠르게 복제 연결을 완료하는 방법

- 여러 레플리카가 복제 연결을 시도하는 경우
  - 디스크를 사용하는 방식의 복제 연결
    - RDB 파일이 생성되는 도중 다른 레플리카에서 복제 연결 요청이 들어옴
    - 다른 복제 연결 요청은 큐에 저장
    - RDB 파일 저장이 완료되면 여러 복제본에 한 번에 복제 연결 시작
  - 디스크를 사용하지 않는 방식의 복제 연결
    - 레플리카와 복제 연결을 통해 복제를 하고 있는 과정에서는 기존 복제가 완료될 때까지 다른 레플리카와 연결 불가능
    - 다른 레플리카들은 기존 복제 연결이 끝날 때까지 큐에서 대기
    - `repl-disless-sync-delay <초>` 설정을 통해 새로운 복제 연결이 들어왔을 때 설정된 시간 만큼 대기
      - 대기 중인 시간 내에 들어온 복제 연결 요청은 한번에 여러 레플리카와 소켓 통신을 연결하는 방식으로 복제 진행
      - 네트워크 유실로 재동기화가 필요한 경우, 한번에 여러 복제 연결 요청이 들어오는 것이 일반적이라 옵션을 사용하는 것이 좋음



### 비동기 방식 복제 연결

- 복제 연결이 된 상태에서 마스터에서 레플리카로 데이터 전달은 비동기 방식으로 동작
- 마스터에 데이터를 변경하는 클라이언트의 요청이 들어오면, 마스터 노드 데이터가 정상적으로 변경되었을 때 성공 응답
- 레플리카에 해당 변경 내역이 정상적으로 반영되었는지는 클라이언트에 전달되지 않음 (높은 성능과 낮은 지연 시간)
- 마스터 노드에서 레플리카로 변경 내역이 전달되기 전 마스터 노드가 죽을 때, 데이터 유실 가능성은 있지만 일반적으로 복제 속도가 빠르기 때문에 유실이 빈번하게 발생하지는 않음



### 복제 ID

- 모든 레디스 인스턴스는 **Replication ID**를 가짐
- 복제 기능을 사용하지 않는 인스턴스라도 **랜덤 스트링 값의 Replication ID**를 부여
- **Replication ID**는 **오프셋**과 쌍으로 존재
- 데이터 변경이 발생할 때마다 오프셋이 1씩 증가
- 마스터 노드에 레플리카를 복제 연결할 경우 `master_replid`의 값이 마스터 노드의 값으로 설정
- 레플리카에서 **마지막으로 복제된 마스터**의 오프셋이 **레플리카의 오프셋**으로 설정
- **마스터 오프셋**과 **레플리카 오프셋**을 비교하면, 레플리카에서 얼마나 마스터를 복제하고 있는지 판단 가능



### 부분 재동기화

- 복제 연결이 끊긴 후 연결 될 때마다 RDB 데이터를 복제하면 비효율성 증가
- 레디스에서는 **부분 재동기화 (partial replication)**을 사용
  - 마스터는 커넥션 유실을 대비하여 **백로그 버퍼**에 레플리카에 전달한 커맨드 데이터들을 저장
  - **Replication ID**와 **오프셋**을 사용하여, 특정 레플리카가 어느 시점까지 복제를 성공했는지 확인 가능
  - 레플리카가 재연결되면 `PSYNC` 커맨드를 호출하여 자신의 **Replication ID**와 **오프셋**을 마스터로 전달
  - 마스터 **백로그 버퍼**에 **레플리카 오프셋** 이후 전달할 커맨드들이 저장되어 있으면, 해당 커맨드만 전달함으로써 부분 재동기화 진행
  - 만약 **백로프 버퍼**에 전달해야 할 커맨드들이 없거나 레플리카가 보낸 **Replication ID**가 현재 마스터와 일치하지 않으면 **전체 재동기화 (full replication)** 진행
- 백로그 크기 : `repl-backlog-size`로 설정 (기본값 1MB)
  - 복제 연결이 끊긴 후 재연결 되었을 때 백로그 크기가 클수록 부분 재동기화가 진행될 가능성도 증가
  - 백로그는 실제로 레플리카가 1개 이상 연결되었을 때 할당되며, 레플리카와 연결이 끊긴 후 `repl-backlog-ttl`만큼 시간이 경과하면 메모리에서 전체 백로그 공간 삭제
- 레플리카에도 백로그 버퍼가 있으며, 레플리카의 백로그 버퍼는 복제 연결이 따로 없더라도 해제 되지 않음

  >  복제본은 언제든지 마스터로 승격될 가능성을 갖고 있기 때문에 복제본에 직접 연결된 복제 연결이 따로 없더라도 백로그 버퍼를 해제하지 않는다. 이는 추후 다른 복제본과 부분 재동기화를 시도할 때 사용된다.[^1]

> 버전 4부터는 복제서버는 항상 `backlog-buffer`를 가지고 있습니다. 이것은 부분 동기화(PSYNC2)를 위해서 필요합니다. [^2]



### Secondary Replication ID

- 한 개의 레플리카 그룹 내의 모든 레디스 노드는 **동일한 Replication ID**를 가짐
- 기존 마스터 노드에 장애가 발생하여, 새로운 레플리카가 마스터로 승격
  - 기존 Replication ID를 그대로 사용할 경우, 장애가 발생한 노드가 살아났을 때 충돌 가능성 발생이 존재하기 때문에 새로 마스터로 승격된 레플리카는 마스터 노드와의 복제가 끊어짐과 동시에 **새로운 Replication ID**를 가짐
  - **새로운 Replication ID**는 `master_replid1`에 저장, **기존 Replication ID**는 `master_replid2`에 저장
- 마스터로 승격되지 않은 기존 레플리카들이 승격 마스터 노드와 복제 연결
  -  `master_replid2`에 **동일한 Replication ID**를 가지고 있으면, 같은 복제 그룹으로 인식
  - 승격된 마스터 노드에 동기화를 위한 백로그 데이터가 존재할 경우, 부분 재동기화만으로 기존 레플리카들과 연결 가능



### 읽기 전용 모드로 동작하는 복제본 모드

- 레플리카는 기본적으로 읽기 전용 모드로 동작
- 새로운 레플리카에 새로운 데이터를 저장하는 것은 불가능
- `replica-read-only` 설정을 통해 관리
- 위 설정을 해제하면, 레플리카 노드에도 새로운 데이터 저장은 가능
  - 레플리카가 재시작되거나 커넥션이 유실되어 마스터와 전체 재동기화를 수행하면 레플리카에서 새로 저장한 데이터는 전부 제거
  - 레플리카에 쓰는 데이터는 로컬에만 적용되기 때문에, 레플리카 노드에 복제 연결을 하더라도 데이터 전달 되지 않음
  - 레플리카에 복제 연결을 하면 언제나 최상위 마스터가 연결할 레플리카에 보낸 데이터만 복제



### 유효하지 않은 복제본 데이터

- 레플리카의 데이터와 마스터 노드의 데이터가 일치하지 않는 상태
  - 마스터와 레플리카 간 연결이 끊어짐
  - 복제 연결 시작 후 복제가 완료되지 않은 상태
- `replica-serve-stale-data`가 설정되어 있으면, 유효하지 않은 데이터라도 클라이언트가 레플리카로 데이터를 요청할 경우 데이터를 반환
- 위 설정을 끄면, `INFO`, `CONFIG`, `PING` 등 일부 기본 커맨드를 제외한 나머지는 `SYNC With master in progress` 오류 반환



### 백업을 사용하지 않는 경우에서의 데이터 복제

- 백업을 사용하지 않는 경우, 서버 재부팅 후 레디스 자동 재시작하지 않는 것이 좋음
- 백업 되지 않는 상태에서 레디스가 다시 시작할 경우, 재시작 된 마스터 노드는 데이터가 전부 삭제된 상태
- 장애가 발생하지 않아 데이터를 가지고 있던 레플리카가 살아난 마스터 노드에 복제 연결을 다시 시도할 경우, 마스터 노드의 빈 데이터를 복제하기 때문에 자신의 모든 데이터를 삭제
- 기존 마스터 노드를 자동 재시작 하지 않는 경우, 데이터를 가지고 있는 레플리카로 연결하거나 레플리카에 존재하는 데이터를 마스터 노드에 복원하는 방식으로 운영 가능
- 데이터 안정성을 위해서는 레디스 백업을 사용하는 것이 좋음







[^1]: 개발자를 위한 레디스
[^2]: [redis-gateway](https://redisgate.kr/redis/configuration/param_repl-backlog-size.php)