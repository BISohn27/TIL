# Controller

- 파티션 리더 선출을 담당
- 카프카 클러스터 중 하나의 브로커가 컨트롤러 역할
- 파티션의 ISR(In-Sync-Replica) 리스트 중 리더를 선출
- ISR 리스트는 주키퍼에 보관
- 새로운 리더를 선출하면 새로운 리더에 대한 정보를 주키퍼에 기록하고, 새로운 리더가 선출되었음을 모든 브로커에 전달
- 모든 읽기/쓰기는 파티션 리더를 통해서 수행되기 때문에 파티션 리더가 없으면 클라이언트(프로듀서/컨슈머)에서는 에러가 발생
- 클라이언트에 설정된 재시도 숫자만큼 재시도 진행  
  → 클라이언트 재시도 가능 횟수 내에 리더 선출 필요

## 장애 상황에서 파티션 리더 선출 과정

1. 파티션 리더에 장애 발생
2. 주키퍼가 브로커 연결 상태 이상을 발견하여, ISR에 변화가 생겼음을 감지
3. 주키퍼 워치를 통해 컨트롤러가 리더 파티션에 문제가 생겼음을 감지, ISR 리스트 중 하나를 새로운 파티션 리더로 선출
4. 컨트롤러는 새로운 파티션 리더 정보를 주키퍼에 기록
5. 새로운 파티션 리더 정보를 현재 활성화 되어 있는 모든 브로커에게 전파

- 파티션 개수가 많아질 경우, 브로커 하나가 맡아야 하는 파티션 리더 수도 많아지기 때문에 브로커 한 개의 장애는 파티션 리더 선출 과정을 많이 발생 시킴
  - `1개 파티션 리더 선출 소요 시간 * 장애가 발생한 브로커가 맡은 파티션 리더 수` 만큼 카프카와 클라이언트 간 통신 문제가 발생하기 때문에 카프카는 리더 선출 시간 단축을 위한 최적화를 진행해옴

## Graceful 종료

1. 관리자에 의해 종료 시그널(SIG_TERM)이 브로커에 전달
2. SIG_TERM 시그널을 받은 브로커는 컨트롤러에 알림
3. 컨트롤러는 리더 선출 진행하여, 해당 정보를 주키퍼에 기록
4. 리더 선출 후 컨트롤러는 새로 선출된 리더 정보를 모든 브로커에 알림
5. 컨트롤러는 리더 선출 과정이 끝난 후 종료 시그널을 받은 브로커에게 정상 종료 응답을 보냄
6. 응답을 받은 브로커는 캐시에 있는 내용을 디스크에 저장하고 종료

## 비정상 종료와 정상 종료 차이

- 정상 종료
  - 다운타임 최소화
  - 파티션 리더 선출 과정에서 일시적 다운타임은 발생
  - 리더 선출 과정에 있는 파티션을 제외한 나머지 파티션은 활성화 상태로 클라이언트의 요청을 처리하며 순차적으로 리더 선출 진행
- 비정상 종료
  - 파티션 리더가 없는 상태이기 때문에 비정상 종료가 된 브로커가 파티션 리더를 맡은 모든 파티션에 파티션 리더가 선출될 때까지 다운타임이 지속
  - 컨트롤러는 순차적으로 리더를 선출하므로 마지막에 리더가 선출 되는 파티션은 앞선 파티션들의 리더 선출이 완료 때까지 대기
- 정상 종료의 경우 모든 로그를 디스크에 동기화할 시간이 존재, 비정상의 경우 모든 로그 동기화하지 못하고 종료  
  → 장애가 발생한 브로커가 다시 복구되면, 로그 복구를 위한 많은 시간 소요

# 로그 세그먼트

- 로컬 디스크 **로그 세그먼트** 파일에 카프카 메세지를 정해진 형식에 맞춰 저장
- 메세지 본문
- 메세지 키
- 메세지 오프셋
- 메세지 크기
- 로그 세그먼트는 기본적으로 1GB 마다 롤링  
  → 로그 세그먼트 크기가 1GB에 도달하면 기존 파일은 클로즈 후 새로운 세그먼트 생성
- 1GB 크기의 로그 세그먼트가 계속 쌓일 경우를 대비하여 관리 전략 필요
  - 로그 세그먼트 삭제
  - 로그 세그먼트 컴팩션

## 로그 세그먼트 삭제

- 기본적인 로그 세그먼트 관리 정책
- `log.cleanup.policy = delete`
- `retention.ms` 설정 값보다 오래된 로그 세그먼트 파일은 삭제 (기본 값은 7일)
- `log.retention.check.interval.ms` 설정 값 주기로 retention을 체크 (기본 값은 5분)
- 로그 세그먼트 파일명의 숫자는 해당 세그먼트 파일을 생성할 시점에 처음 저장된 메세지 offset 번호

## 로그 세그먼트 컴팩션

- 로컬 디스크에 저장되어 있는 세그먼트를 대상으로 동작하며, 현재 사용되고 있는 세그먼트를 제외한 나머지 세그먼트 파일들을 대상으로 실행
- 로그 세그먼트는 레코드의 키 값을 기준으로 가장 마지막 메세지만 보관하고 나머지는 삭제
- `__consumer_offset` 카프카 내부 토픽은 컴팩션으로 커밋 정보 보관
  - 키는 토픽 명과 컨슈머 그룹명이고, 밸류는 오프셋 커밋 정보
  - 로그 컴팩션이 진행되면 토픽-컨슈머 그룹의 가장 마지막 커밋 오프셋만 남기고 삭제
- 구매 현황 상태를 보여주는 시스템은 구매 상품의 가장 마지막 상태만 사용자에게 노출되므로, 로그 컴팩션을 사용해서 가장 마지막 상태 메세지를 제외한 나머지를 삭제
- 메세지의 키는 필수 값이 아니기 때문에 로그 컴팩션을 사용할 경우 메세지 키를 반드시 넣어야 함
- 로그 컴팩션의 가장 큰 장점은 장애 발생 후 복구 시 빠르게 최신 상태만 복구 가능
- 키 값을 기준으로 가장 마지막 상태만 필요한 유스케이스에 사용
