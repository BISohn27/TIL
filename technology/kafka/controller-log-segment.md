# Controller

- 파티션 리더 선출을 담당
- 카프카 클러스터 중 하나의 브로커가 컨트롤러 역할
- 파티션의 ISR(InSync-Replica) 리스트 중 리더를 선출
- ISR 리스트는 주키퍼에 보관
- 새로운 리더를 선출하면 새로운 리더에 대한 정보를 주키퍼에 기록하고, 새로운 리더가 선출되었음을 모든 브로커에 전달
- 모든 읽기/쓰기는 파티션 리더를 통해서 수행되기 때문에 파티션 리더가 없으면 클라이언트(프로듀서/컨슈머)에서는 에러가 발생하고, 클라이언트에 설정된 재시도 숫자만큼 재시도 진행  
  → 클라이언트 재시도 가능 횟수 내에 리더 선출 필요

## 장애 상황에서 파티션 리더 선출 과정

1. 파티션 리더에 장애 발생
2. 주키퍼가 브로커 연결 상태 이상이 발생하면, ISR에 변화가 생겼음을 감지
3. 주키퍼 워치를 통해 컨트롤러는 리더 파티션에 문제가 생겼음을 감지하고, ISR 리스트 중 하나를 새로운 파티션 리더로 선출
4. 컨트롤러는 새로운 파티션 리더의 정보를 주키퍼에 기록
5. 새로운 파티션 리더의 정보를 현재 활성화 되어 있는 모든 브로커에게 전파

- 파티션 개수가 많아질 경우, 하나의 브로커가 맡는 파티션 리더 수도 많아지므로, 한 개의 브로커 장애는 많은 파티션 리더 선출 과정을 필요로 함
  - `1개 파티션 리더 선출 소요 시간 * 장애가 발생한 브로커가 맡은 파티션 리더 수` 만큼 카프카와 클라이언트 간 통신이 끊기는 문제가 발생하기 때문에, 카프카는 성능 향상을 통해 파티션 리더 선출 시간을 단축 시킴

## Graceful 종료

1. 관리자에 의해 종료 시그널(SIG_TERM)가 브로커에 전달
2. SIG_TERM 시그널을 받은 브로커는 컨트롤러에 알림
3. 컨트롤러는 리더 선출 작접 진행, 해당 정보를 주키퍼에 기록
4. 새로 선출된 리더 정보를 컨트롤러가 모든 브로커에 알림
5. 컨트롤러는 리더 선출 과정이 끝나고, 시그널을 받은 브로커에게 정상 종료 응답을 보냄
6. 응답을 받은 브로커는 캐시에 있는 내용을 디스크에 저장하고 종료

## 비정상 종료와 정상 종료 차이

- 정상 종료
  - 다운타임 최소화
  - 파티션 리더 선출 과정은 일시적 다운타임 발생
  - 리더 선출 대상 파티션을 제외한 나머지 파티션은 활성화 상태로 컨트롤러에 의해 순차적으로 진행
- 비정상 종료
  - 이미 파티션 리더가 없는 상태이기 때문에 다운타임은 파티션 리더가 선출될 때까지 지속
  - 컨트롤러는 순차적으로 리더를 선출하기 때문에, 마지막 리더 선출 파티션은 앞선 파티션들의 리더 선출이 진행될 때까지 대기
- 정상 종료의 경우 모든 로그를 디스크에 동기화할 시간이 존재, 비정상의 경우 모든 로그 동기화하지 못하고 종료  
  → 장애가 발생한 브로커가 다시 복구되면, 로그 복구를 위한 많은 시간 소요

# 로그 세그먼트

- 카프카의 메세지는 **로그 세그먼트** 파일에 정해진 형식에 맞춰 로컬 디스크에 저장
  - 메세지 본문
  - 메세지 키
  - 메세지 오프셋
  - 메세지 크기
- 로그 세그먼트는 기본적으로 1GB 크기로 롤링  
  → 로그 세그먼트 크기가 1GB에 도달하면 기존 파일은 클로즈하고, 새로운 세그먼트 생성
- 1GB 크기의 로그 세그먼트가 계속 쌓일 경우를 대비하여 관리 전략 필요
  - 로그 세그먼트 삭제
  - 로그 세그먼트 컴팩션

## 로그 세그먼트 삭제

- 기본적인 로그 세그먼트 관리 정책
- `log.cleanup.policy = delete`
- `retention.ms` 설정을 통해, 설정 값보다 로그 세그먼트 보관 기간이 크면 삭제 (기본 값은 7일)
- `log.retention.check.interval.ms` 설정을 통해 얼마 간격으로 retention을 체크할 것인지 설정 (기본 값은 5분)
- 로그 세그먼트 파일의 숫자는 해당 파일을 생성할 때 시작되는 로그 offset 번호

## 로그 세그먼트 컴팩션

- 로컬 디스크에 저장되어 있는 세그먼트를 대상으로 동작하며, 현재 활성화 된 세그먼트를 제외한 나머지 세그먼트들을 대상으로 실행
- 로그 세그먼트는 레코드의 키 값을 기준으로 가장 마지막 세그먼트만 보관
- `__consumer_offset` 카프카 내부 토픽에서 키는 토픽 명과 컨슈머 그룹명이고, 밸류는 오프셋 커밋 정보이기 때문에 로그 컴팩션을 진행할 때, 토픽-컨슈머 그룹의 가장 마지막 커밋 오프셋만 남기고 삭제
- 구매 현황 상태를 보여주는 시스템에서 구매자의 가장 마지막 상태만 사용자에게 노출되므로, 로그 컴팩션을 사용하여 가장 마지막 상태를 제외한 나머지를 삭제
- 메세지의 키는 필수 값이 아니기 때문에 로그 컴팩션을 사용할 경우 메세지 키를 반드시 넣어야 함
- 로그 컴팩션의 가장 큰 장점은 장애 발생 후 복구 시 빠르게 최신 상태만 복구 가능
- 키 값을 기준으로 가장 마지막 상태만 필요한 유스케이스에 사용
