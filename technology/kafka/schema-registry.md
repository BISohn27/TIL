# 스키마 레지스트리

## 스키마를 사용하는 이유

- 스키마는 정보를 구성하고 해석하는 것을 도와주는 프레임워크나 개념
- 스키마 레지스트리는 다음의 문제를 해결하기 위해 사용
  - 사전에 정의되지 않은 데이터를 클라이언트가 저장하면 소비하는 쪽에서 파싱 문제를 유발
  - 여러 시스템에 사용되는 데이터의 구조를 관련 부서에 알리는 것은 굉장히 힘듬
  - 데이터의 구조를 수정, 삭제하기 위해 상호 협의를 하기 위해서는 많은 노력과 시간이 소모
  - 데이터를 분석, 적재하는 작업보다 데이터를 파싱하는 작업에 많은 시간이 소모되는 현실에서 형식에서 벗어난 데이터를 찾아 파싱하고 에러를 처리하기 위한 로직을 작성하는 것은 비효율적

## 별도로 설치하는 스키마 레지스트리를 통해 토픽 스키마를 관리할 수 있다

![](https://miro.medium.com/v2/resize:fit:1200/1*dm9uhQur3mUOPA4x74t3SA.png)

- 스키마 레지스트리는 컨플루언트에서 개발한 상용 애플리케이션
- 카프카 외부에 별도로 설치되어 메세지를 전송하는 프로듀서와 메세지를 소비하는 컨슈머 각각 직접 통신
- 프로듀서에 의해 등록된 스키마 정보를 카프카 내부 토픽에 저장
- 프로듀서의 동작
  - 프로듀서는 Serializer로 `KafkaAvroSerializer` 사용
  - 위 직렬화를 사용하면 스키마가 유효한지 확인하고 유효하지 않으면 스키마를 등록하고 캐시
  - 스키마 레지스트리는 프로듀서가 보낸 스키마가 진화한 스키마인지 확인하고, 순차적으로 1씩 증가하지만 반드시 연속적인 것은 아닌 고유 ID를 할당하고 프로듀서에게 반환
  - 프로듀서는 **스키마 ID**와 **메세지**를 카프카로 전송
- 컨슈머는 `KafkaAvroDeserializer`를 사용해 **스키마 ID**로 스키마 레지스트리로부터 스키마를 가져온 후 메세지를 역직렬화
  - 컨슈머가 스키마 ID를 갖고 있지 않으면 스키마 레지스트리로부터 가져옴

## 스키마 레지스트리의 메세지 포멧

- 스키마 레지스트리는 **Avro**, **Proto Buffer**, **JSON**을 지원
- 아파치에서 만든 바이너리 포멧 **Avro**이 대표적인 메세지 포멧
- Avro
  - 오픈소스 직렬화 시스템
  - 바이너리 데이터 포맷을 지원
  - JSON과 매핑 가능
  - 메세지마다 필드 네임들이 포함되지 않아 효율적인 전송 가능
  - 바이너리 형태로 매우 빠름
- 스키마 레지스트리 정의
  ```
  {
    "namespace": "example.avro",
    "type": "record",
    "name": "user",
    "fields": [
        {"name": "name", "type": "string"},
        {"name": "favorite_number",  "type": "int"}
    ]
  }
  ```
  - namespace: 이름을 식별하는 문자열
  - type: record, enums, arrays, maps 등 지원
  - doc: 사용자들에게 스키마 정의에 대한 설명 제공
  - name: 레코드의 이름을 나타내는 문자열로 필수값
  - fields: JSON 배열로, 필드들의 리스트
    - name: 필드의 이름
    - type: boolean, int, long, string
    - doc: 해당 필드의 의미 설명

## 스키마 레지스트리의 옵션 설정

```
listeners=http://0.0.0.0:8081
kafkastore.bootstrap.servers=PLAINTEXT://localhost:9092
kafkastore.topic=_schemas
schema.compatibility.level=full
```

- `kafkastore.topic`: 카프카 토픽을 스키마 저장 및 관리 목적으로 사용
  - 모든 스키마의 제목, 버전, ID 등이 저장
  - 스키마 관리 목적으로 사용되는 메세지들은 순서가 중요하기 때문에 파티션 1로 고정하여 메세지 순서를 보장
  - 토픽의 `cleanup.policy`가 **compact**로 설정되어 토픽은 compact가 수행되고 난 후 항상 해당 키의 가장 최신 메세지만 저장
- `schema.compatibility.level` 설정을 통해 메세지 호환성 레벨 결정(**FULL**, **BACKWARD**, **FORWARD**)

##
