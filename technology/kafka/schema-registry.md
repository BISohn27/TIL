# 스키마 레지스트리

## 스키마를 사용하는 이유

- 스키마는 정보를 구성하고 해석하는 것을 도와주는 프레임워크나 개념
- 스키마 레지스트리는 다음의 문제를 해결하기 위해 사용
  - 사전에 정의되지 않은 데이터를 클라이언트가 저장하면 소비하는 쪽에서 파싱 문제를 유발
  - 여러 시스템에 사용되는 데이터의 구조를 관련 부서에 알리는 것은 굉장히 힘듬
  - 데이터의 구조를 수정, 삭제하기 위해 상호 협의를 하기 위해서는 많은 노력과 시간이 소모
  - 데이터를 분석, 적재하는 작업보다 데이터를 파싱하는 작업에 많은 시간이 소모되는 현실에서 형식에서 벗어난 데이터를 찾아 파싱하고 에러를 처리하기 위한 로직을 작성하는 것은 비효율적

## 별도로 설치하는 스키마 레지스트리를 통해 토픽 스키마를 관리할 수 있다

![](https://miro.medium.com/v2/resize:fit:1200/1*dm9uhQur3mUOPA4x74t3SA.png)

- 스키마 레지스트리는 컨플루언트에서 개발한 상용 애플리케이션
- 카프카 외부에 별도로 설치되어 메세지를 전송하는 프로듀서와 메세지를 소비하는 컨슈머 각각 직접 통신
- 프로듀서에 의해 등록된 스키마 정보를 카프카 내부 토픽에 저장
- 프로듀서의 동작
  - 프로듀서는 Serializer로 `KafkaAvroSerializer` 사용
  - 위 직렬화를 사용하면 스키마가 유효한지 확인하고 유효하지 않으면 스키마를 등록하고 캐시
  - 스키마 레지스트리는 프로듀서가 보낸 스키마가 진화한 스키마인지 확인하고, 순차적으로 1씩 증가하지만 반드시 연속적인 것은 아닌 고유 ID를 할당하고 프로듀서에게 반환
  - 프로듀서는 **스키마 ID**와 **메세지**를 카프카로 전송
- 컨슈머는 `KafkaAvroDeserializer`를 사용해 **스키마 ID**로 스키마 레지스트리로부터 스키마를 가져온 후 메세지를 역직렬화
  - 컨슈머가 스키마 ID를 갖고 있지 않으면 스키마 레지스트리로부터 가져옴

## 스키마 레지스트리의 메세지 포멧

- 스키마 레지스트리는 **Avro**, **Proto Buffer**, **JSON**을 지원
- 아파치에서 만든 바이너리 포멧 **Avro**이 대표적인 메세지 포멧
- Avro
  - 오픈소스 직렬화 시스템
  - 바이너리 데이터 포맷을 지원
  - JSON과 매핑 가능
  - 메세지마다 필드 네임들이 포함되지 않아 효율적인 전송 가능
  - 바이너리 형태로 매우 빠름
- 스키마 레지스트리 정의
  ```
  {
    "namespace": "example.avro",
    "type": "record",
    "name": "user",
    "fields": [
        {"name": "name", "type": "string"},
        {"name": "favorite_number",  "type": "int"}
    ]
  }
  ```
  - namespace: 이름을 식별하는 문자열
  - type: record, enums, arrays, maps 등 지원
  - doc: 사용자들에게 스키마 정의에 대한 설명 제공
  - name: 레코드의 이름을 나타내는 문자열로 필수값
  - fields: JSON 배열로, 필드들의 리스트
    - name: 필드의 이름
    - type: boolean, int, long, string
    - doc: 해당 필드의 의미 설명

## 스키마 레지스트리의 옵션 설정

```
listeners=http://0.0.0.0:8081
kafkastore.bootstrap.servers=PLAINTEXT://localhost:9092
kafkastore.topic=_schemas
schema.compatibility.level=full
```

- `kafkastore.topic`: 카프카 토픽을 스키마 저장 및 관리 목적으로 사용
  - 모든 스키마의 제목, 버전, ID 등이 저장
  - 스키마 관리 목적으로 사용되는 메세지들은 순서가 중요하기 때문에 파티션 1로 고정하여 메세지 순서를 보장
  - 토픽의 `cleanup.policy`가 **compact**로 설정되어 토픽은 compact가 수행되고 난 후 항상 해당 키의 가장 최신 메세지만 저장
- `schema.compatibility.level` 설정을 통해 메세지 호환성 레벨 결정(**FULL**, **BACKWARD**, **FORWARD**)

## 메세지 호환성 레벨은 어떻게 동작하는가?

![](https://miro.medium.com/v2/resize:fit:1104/0*PxX6E7xfjI2K7ayV)
**호환성**이란 두 개의 이상의 시스템이나 소프트웨어, 구성요소가 서로 충돌 없이 작동할 수 있는 능력을 얘기한다. 소프트웨어에서 호환성은 이전 버전과 이후 버전이 충돌 없이 동작할 수 있는지를 말해주는 것으로 자바의 경우에는 **하위 호환성**을 보장해준다. 그러므로 **하위 호환성**을 보장해주는 자바는 이론적으로 이전 버전의 자바로 개발된 애플리케이션을 상위 버전 JVM에서 실행할 수 있다.  
카프카의 경우에도 **스키마 레지스트리**를 사용할 경우 데이터 포멧 버전 간 충돌 없이 파싱할 수 있으며, 어떤 방향으로 파싱이 보장되는지에 따라 **Backward Compatibility(상위 호환성)**, **Forward Compatibility(하위 호환성)**, **Full Compatibility(전체 호환성)** 으로 나눌 수 있다.

### BACKWARD 호환성

- 진화된 스키마(수정된 스키마)를 적용한 컨슈머가 진화 전 스키마(수정 전 스키마)가 적용된 프로듀서가 보낸 메세지를 읽을 수 있도록 허용
- 예)`version 3` 스키마가 적용된 컨슈머가 `version 1` 스키마로 된 메세지를 읽을 수 있음
- `BACKWARD` 설정: 버전이 하나 낮은 메세지를 컨슈머가 읽을 수 있음
- `BACKWARD_TRANSITIVE`: 버전이 낮은 모든 메세지를 컨슈머가 읽을 수 있음
- 변경 허용 목록: 기본 전제는 없으면 기본 값으로 채우고, 있으면 무시
  - 필드 삭제
  - 기본 값이 지정된 필드 추가
- 스키마의 버전 업데이트
  - **상위 버전 스키마를 가진 컨슈머**가 **하위 버전을 가진 프로듀서**가 전송한 메세지를 읽을 수 있는 것을 착안
    1. **컨슈머**는 **하위 버전 메세지를 읽을 수 있기 때문에** **컨슈머**를 먼저 **상위 버전 스키마**로 업데이트하여 상위, 하위 버전 메세지를 모두 읽을 수 있는 상태로 만듬
    2. **프로듀서**를 순차적으로 업데이트하여 최종적으로 **상위 버전 스키마**를 사용하도록 변경

### FORWARD 호환성

- 진화된 스키마(수정된 스키마)가 적용된 프로듀서가 보낸 메세지를 진화 전 스키마(수정 전 스키마) 컨슈머가 읽을 수 있도록 허용
- 예) `version 1` 스키마가 적용된 컨슈머가 `version 3` 스키마로 된 메세지를 읽을 수 있음
- `FORWARD`: 버전이 하나 높은 메세지를 컨슈머가 읽을 수 있음
- `FORWARD_TRANSITIVE`: 버전이 높은 모든 메세지를 컨슈머가 읽을 수 있음
- 번경 허용 목록: 기본 전제는 있으면 무시, 없으면 기본 값으로 채움
  - 필드 추가
  - 기본 값이 지정된 필드 삭제
- 스키마의 버전 업데이트
  - **하위 버전 스키마를 가진 컨슈머**가 **상위 버전을 가진 프로듀서**가 전송한 메세지를 읽을 수 있음
    1. **컨슈머**는 **상위 버전 메세지를 읽을 수 있기 때문에** **프로듀서**를 **상위 버전 스키마**로 우선 업데이트
    2. **컨슈머**를 순차적으로 업데이트하여 최종적으로 **상위 버전 스키마**를 모두 사용하도록 변경

### FULL 호환성

- **FORWARD**와 **BACKWARD** 모두 지원 가능
- 호환성 제약 없이 모두 편하게 사용할 수 있음
- `FULL`: 위로 버전 하나, 아래로 버전 하나 모두 2개의 버전 스키마를 지원
- `FULL_TRANSITIVE`: 위, 아래 모든 버전 스키마를 지원
- 변경 허용 목록: 기본 전제는 추가, 삭제 모두 기본 값으로 채움
  - 기본 값이 지정된 필드 추가
  - 기본 값이 지정된 필드 삭제
- 스키마 업데이트는 어느 순서로 해도 상관 없음
