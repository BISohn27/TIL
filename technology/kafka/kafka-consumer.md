# Kafka Consumer

## 카프카는 pull 방식으로 메세지를 읽는다.

- 전통적으로 메세지를 읽는 방식은 크게 **pull** 방식과 **push** 방식이 존재
- 카프카는 **pull** 방식으로 메세지를 소비
- **push**
  - 장점
    - 거의 실시간으로 메세지를 전달 받을 수 있음
    - 메세지를 요청하는 쪽에서 요청 로직 구현이 필요 없어 단순함
    - 빠른 반응 요구 사항에 적합 (예. SMTP 메일 시스템, 각종 알림 시스템)
  - 단점
    - 메세지 생성 즉시 발송하거나 모아뒀다 발송하는 방식으로 메세지 소비 속도를 생산자가 조절하기 때문에 소비하는 쪽에서 처리량을 따라가지 못할 수 있음
    - 메세지 소비 실패 처리 백프레셔를 구현하기 어려움
    - 재전송을 언제 어떻게 해야 되는지 명확하지 않음
- **pull**
  - 장점
    - 소비하는 쪽에서 요청을 조절 하기 때문에 일시적으로 소비자의 처리량 저하가 발생해도, 지연이 해결되면 다시 따라잡을 수 있음
    - 소비하는 쪽에서 소비할 메세지 수를 결정하기 때문에 메세지 소비 수를 조절하며 배치 작업 가능
  - 단점
    - 메세지를 소비하는 쪽에서 메세지를 요청하기 때문에 실시간 성은 상대적으로 떨어짐
    - 지속적으로 메세지를 가지고 있는 쪽에 요청해야 되기 때문에 상대적으로 요청 낭비가 발생

## 카프카 컨슈머는 무슨 일을 할까?

- 컨슈머는 카프카로부터 메세지를 읽어와 처리하는 역할
- 파티션 리더로부터 **offset**을 활용해 읽어올 메세지를 요청
- 컨슈머는 **offset**을 사용하여 가장 마지막으로 읽은 메세지 이후를 읽어오거나 특정 위치에 있는 메세지를 다시 읽어드릴 수 있음

## 카프카는 어떻게 오프셋을 관리할까?

- **offset**

  - 다음 메세지를 읽을 위치를 나타내는 일종의 포인터
  - 토픽의 파티션 마다 관리되며, 파티션을 담당하는 컨슈머는 바뀔 수 있기 때문에 컨슈머가 변경되더라도 기존 컨슈머의 마지막 메세지 위치부터 읽을 수 있어야 함
  - offset은 항상 다음 읽어올 위치를 저장

- **\_\_consumer_offsets**

  - 컨슈머는 지정된 토픽에서 메세지를 읽은 뒤 읽어 온 위치의 오프셋 정보를 내부 토픽인 위의 토픽에 저장
  - **컨슈머 그룹**, **토픽**, **파티션** 등의 내용을 통합 기록
  - `offsets.topic.num.partitions`: 오프셋 관리 파티션 수 (기본값 50)
  - `offsets.topic.replication.factor`: 오프셋 관리 파티션의 리플리케이션 팩터 수 (기본값 3)

## 컨슈머는 그룹으로 구성된다

- 컨슈머들은 `group.id`으로 설정된 그룹에 참여하여 그룹 단위로 여러 토픽을 소비
- 토픽은 파티션들로 구성되어 있고, 파티션 하나에는 그룹 내 한개의 컨슈머가 할당
- 컨슈머 그룹 내 컨슈머 수보다 파티션의 수가 많을 경우, 한 개의 컨슈머는 여러 개의 파티션을 담당
- 토픽은 컨슈머 그룹 별로 소비되기 때문에 컨슈머 그룹 마다 독립적인 오프셋을 관리하며 소비 (다른 컨슈머 그룹 간에는 메세지를 중복 소비)
- 컨슈머 그룹 관리는 **컨슈머 코디네이터**에 의해 진행

## 그룹 코디네이터는 컨슈머 그룹을 관리한다

![](https://images.ctfassets.net/gt6dp23g0g38/6smQqDfuZgjNPFeB7iNHLb/d237de3390dcb0cada914c06f4142053/Kafka_Internals_065.png)

- 그룹 내 컨슈머들은 언제든지 컨슈머 그룹을 떠날 수 있음
- 새로운 컨슈머는 컨슈머 그룹에 합류할 수 있음
- 컨슈머 그룹의 변화가 생기면 각 컨슈머들에게 작업을 균등하게 분배하는 **컨슈머 리밸런싱**이 동작
- 그룹 코디네이터는 그룹 별로 존재하며, 클러스터의 브로커 중 하나가 담당
- 그룹 코디네이터는 컨슈머 그룹이 구독한 토픽의 파티션들과 그룹의 멤버들을 트래킹
- 그룹 코디네이터는 컨슈머 그룹에 할당된 `__consumer_offsets` 내부 토픽 파티션의 파티션 리더 브로커에 생성
  - 그룹 코디네이터도 파티션 리더이고, `__consumer_offsets` 내부 토픽 파티션도 리플리케이션되어 있음
  - 만약 파티션 리더 브로커에 문제가 생길 경우, 다른 토픽 파티션과 마찬가지로 ISR 그룹 내 팔로워 중 하나가 파티션 리더로 선정되어 선정된 파티션 리더에 그룹 코디네이터가 생성

### 컨슈머 그룹이 생성되는 과정

1. 그룹 코디네이터를 찾음
   ![](https://images.ctfassets.net/gt6dp23g0g38/4N3txDiCwLsYg502212Lx4/43a4f6797bb868f027cd87a6663fc84d/Kafka_Internals_066.png)
   1-1. 클러스터 브로커 중 하나에 `FindCoordinator` 요청을 보냄  
   1-2. `group.id 해시 % 내부 파티션 수`로 `__consumer_offsets` 토픽에 메타 데이터를 저장할 파티션 결정  
   1-3. 컨슈머 그룹의 정보를 저장하는 `__consumer_offsets` 토픽 파티션 리더를 그룹 코디네이터로 지정하여 해당 브로커의 호스트를 응답으로 보냄
2. 컨슈머 그룹에 합류
   ![](https://images.ctfassets.net/gt6dp23g0g38/3tDRpjViBVqd1UdRr7vT26/4ba46426533ebd6414eed5d4d7e43413/Kafka_Internals_067.png)
   2-1. 컨슈머가 `JoinGroup` 요청을 구독할 토픽 정보와 함께 그룹 코디네이터 브로커로 전송  
   2-2. 그룹 코디네이터는 컨슈머 리더(일반적으로 처음 요청을 보낸 컨슈머)를 지정  
   2-3. 응답 메세지에 컨슈머에 할당한 `memberId`를 응답. 컨슈머 리더에게는 컨슈머 그룹 멤버 목록과 구독 정보도 함께 응답
   2-4. 컨슈머 리더는 응답 받은 컨슈머 멤버 목록과 구독 정보로 파티션 할당 전략을 사용해서 파티션 할당 시작
3. 컨슈머에 파티션 할당
   ![](https://images.ctfassets.net/gt6dp23g0g38/5AcaJ8KtM5YmmI9Ueomz25/2fcac2290d58d784f1522a41d8d48df2/Kafka_Internals_068.png)
   3-1. 컨슈머 리더는 그룹 코디네이터한테 받은 컨슈머 멤버 목록과 구독 정보로 파티셔너를 통해 할당 시작  
   3-2. 파티셔너가 할당을 완료하면, 컨슈머 리더는 그룹 코디네이터에게 `SyncGroupRequest`을 컨슈머 리더 `memberId`와 파티셔너가 할당한 결과를 전송  
   3-3. 다른 컨슈머도 그룹 코디네이터에게 `SyncGroupRequest` 요청을 보내지만 자신의 `memberId`만 보냄  
   3-4. 그룹 코디네이터는 할당 결과를 사용해서 각 컨슈머에게 실제 파티션 할당을 진행

## 컨슈머들에게 파티션을 할당하는 파티션 할당 전략

### 레인지 파티션 할당 전략

![](https://images.ctfassets.net/gt6dp23g0g38/2I7BijMOpFeFxkdeyH5kFN/9f00009b876cf3339d6c646e53143cd8/Kafka_Internals_069.png)

- 컨슈머 그룹이 구독한 파티션과 컨슈머 그룹을 순서대로 나열
- `전체 파티션 수 / 컨슈머 수`만큼 컨슈머 그룹 내 컨슈머에게 파티션을 할당
- 위의 과정을 진행한 후 남은 파티션은 순서가 앞선 컨슈머부터 차례대로 파티션을 추가 할당
- 이 전략은 순서가 앞선 파티션에게 더 많은 파티션이 할당되기 때문에 불균형이 발생
- 그럼에도 불구하고 이 전략을 사용하는 이유는 컨슈머 그룹이 구독한 전체에서 토픽에서 동일한 레코드 키를 가진 레코드는 같은 컨슈머에서 처리할 수 있기 때문  
  (이 전략을 사용하면 여러 토픽에 걸쳐 동일한 키를 가진 이벤트가 발행될 때 같은 컨슈머에서 처리 가능)

### 라운드 로빈 파티션 할당 전략

![](https://images.ctfassets.net/gt6dp23g0g38/4OL5b1FeAv3mSXM99a5IxA/2ea543db29d3d1a0b26cf57a312208ab/Kafka_Internals_070.png)

- 구독 대상 토픽들의 파티션을 토픽에 관계 없이 순서대로 나열
- 순서대로 나열된 파티션을 컨슈머 그룹 내 컨슈머에게 돌아가면서 하나씩 할당
- 파티션 할당 전략 중 모든 컨슈머에게 가장 균등하게 파티션을 할당할 수 있는 전략

### 스티키 파티션 할당 전략

- 라운드 로빈 파티션 할당 전략의 변형
- 스티키 파티션 할당 전략은 두가지 목적이 존재
  1. 가능한 균형 있게 파티션을 할당
  2. 재할당이 발생할 때 되도록 기존의 파티션 정보를 보장하도록 기존 파티션에 컨슈머를 재할당
- 스티키 파티션 할당 전략은 위의 목적 중 첫번째 목적이 우선하기 때문에 기존 파티션에 컨슈머를 재할당하는 것이 항상 보장되지 않아 새로운 파티션에 컨슈머가 할당될 수 있음
- 최초 파티션 할당은 **라운도 로빈 파티션 할당 전략**과 흡사
- 리밸런싱 과정에서 균등한 파티션 할당이 깨지지 않는 선에서 최대한 기존 파티션에 컨슈머를 재할당 시도
- **스티키 파티션 할당 전략**이 가능할 수 있는 이유
  - 가장 많이 파티션을 할당 받은 컨슈머와 가장 적게 파티션을 할당 받은 컨슈머 간 파티션 할당 수 차이는 **최대 1개**
  - 기존에 존재하는 파티션 할당은 최대한 유지
  - 재할당 동작 시 유효하지 않은 모든 파티션 할당은 제거
  - 할당되지 않은 파티션들은 균형을 맞추는 방법으로 컨슈머들에게 할당

### 협력적 스티키 파티션 할당 전략

- 할당 전략 자체는 **스티키 파티션 할당 전략**과 같음
- 차이는 리밸런싱 과정에서 전체 컨슈머에서 파티션을 해제한 후 재할당 하지 않고 **파티션 해제가 필요한 컨슈머에게서만 해당 파티션을 해제**와 **파티션 할당이 필요한 컨슈머에게만 해제한 파티션을 할당** 2번의 부분적 재할당을 진행
- `EAGAR` 리밸런스 프로토콜을 `COOPERATIVE` 리밸런스 프로토콜로 변경
- `EAGAR` 리밸런스 프로토콜
  - 컨슈머 리밸런스 동작 시 할당된 모든 파티션을 항상 취소
  - 하나의 파티션은 한 개의 컨슈머가 담당한다는 규칙을 위해 컨슈머의 소유권을 변경하기 위해서는 재할당할 파티션을 우선 소유권 취소 후 컨슈머에게 할당 필요
  - 그룹 내 여러 파티션에 대한 소유권 변경 작업이 동시에 이뤄져야 하기 때문에 구현 로직 단순화 필요
  - 전체 파티션 소유권을 취소하기 때문에 한번의 리밸런싱 동작으로 모든 컨슈머와 파티션 매핑이 이뤄질 수 있음
  - 모든 파티션 소유권을 취소하게 되면, 재할당될 때까지 컨슈머들이 메세지를 처리하지 못하는 다운타임 발생
- `COOPERATIVE` 리밸런스 프로토콜
  - 안전하게 파티션의 소유권을 이동하기 위해 리밸런싱 작업이 여러차례 걸쳐 진행하는 것은 받아드릴 수 있는 트레이드 오프라는 생각에서 출발

## 컨슈머의 오프셋은 어떻게 추적할까?

![](https://images.ctfassets.net/gt6dp23g0g38/F1Nqrh5ElviKJKLuzO6gn/73a3f20420af1749bc74d2d7528cbf45/Kafka_Internals_071.png)

- 주어진 파티션은 항상 하나의 컨슈머에 할당
- 파티션 내 레코드는 항상 오프셋 순서대로 소비
- 컨슈머는 항상 소비한 마지막 오프셋만 추적 필요
- 컨슈머는 마지막 오프셋을 담은 `CommitOffsetRequest` 요청을 그룹 코디네이터(결국 `__consumer_offsets` 내부 토픽 내 파티션에 읽기/쓰기 권한이 있는 파티션 리더)에게 해당 정보를 전송
- 그룹 코디네이터는 전달 받은 정보를 `__consumer_offsets` 내부 토픽 파티션에 기록

## 컨슈머의 시작 또는 리밸런싱 과정에서 시작 오프셋은 어떻게 결정될까?

- 컨슈머는 할당된 파티션의 가장 마지막에 커밋된 오프셋을 얻기 위해 `OffsetFetchRequest` 요청을 그룹 코디네이터에게 보냄
- 가장 마지막에 커밋된 오프셋을 그룹 컨슈머로부터 얻게 되면, 컨슈머는 메세지 소비 작업을 진행
- 만약 컨슈머가 새로 시작하여 컨슈머 그룹에 할당된 파티션에 커밋된 오프셋이 없으면 `auto.offset.reset` 설정 값으로 `earliest`(처음부터 시작)이나 `latest`(마지막부터 시작)으로 오프셋을 설정

## 컨슈머 리밸런싱 과정은 어떻게 진행될까?

### 컨슈머 그룹의 리밸린성 트리거

![](https://images.ctfassets.net/gt6dp23g0g38/235g0BGQoTUrdzhrPVaJ6w/b11bae4c0ea05aeff38f8300c5386a97/Kafka_Internals_074.png)

- 컨슈머의 리밸런싱을 유발하는 이벤트
  - 컨슈머가 그룹 코디네이터에게 Heartbeat 신호를 전송하지 못함
    - `heatbeatr.interval.ms`: 컨슈머가 그룹 코디네이터로 Heartbeat 신호를 전송하는 주기 (일반적으로 timeout 시간의 1/3 설정, 기본값 3초)
    - `session.timeout.ms`: 특정 컨슈머가 Heartbeat 신호를 주지 못할 때 문제가 생겼다고 판단하는 시간. 명시된 timeout 내에 신호를 주지 못하면 컨슈머 리밸린싱 발생 (기본값 10초)
  - 새로운 컨슈머가 컨슈머 그룹에 합류
  - 그룹이 구독한 토픽에 새로운 파티션이 추가
  - 그룹이 와일드 카드 형태로 토픽을 구독하고 있는데, 와일드 카드 포멧에 맞는 새로운 토픽이 생성
  - 컨슈머 그룹의 시작
  - 컨슈머가 주기적으로 파티션에서 레코드를 가져오는 `poll()` 메소드를 마지막 호출 후 특정 시간이 지나도록 다시 `poll()` 메소드를 호출하지 않는 경우
    - `max.poll.interval.ms`: 컨슈머가 `poll()` 메소드를 추가 호출하지 않아 문제가 있다고 판단되는 시간 (기본값 5분)

### 그룹 코디네이터는 리밸런싱 알림을 컨슈머에게 보낸다

![](https://images.ctfassets.net/gt6dp23g0g38/izCSKstOIQMZ8Blh7BCWg/8194eb9df3ff686cd62e1b1d7dda8c01/Kafka_Internals_075.png)

- 그룹 코디네이터는 리밸런싱이 필요한 이벤트가 발생했을 때 컨슈머에게 리밸런싱을 시작한다는 알림을 보냄
- 일반적으로 컨슈머의 `HeartbeatResponse`나 `OffsetFetchResponse`로 전달

### 리밸런싱은 **stop-the-world**를 유발한다

![](https://images.ctfassets.net/gt6dp23g0g38/3AvvIpWKyXtRxH8g8Oev5j/d8255b0fa80975f2b0b0febe772c52f9/Kafka_Internals_076.png)

- 그룹 코디네이터로부터 리밸런싱 알림을 받은 컨슈머는 현재 할당된 파티션을 취소
- 이전 할당된 파티션에 관한 데이터를 유지하고 있다면, 해당 데이터도 함께 정리
- 할당되었던 파티션을 해제하고 나면, 새로운 컨슈머가 합류한 것과 동일한 프로세스를 진행
- `JoinGroupRequest` 요청을 그룹 코디네이터에게 보내서 그룹에 합류
- `SyncGroupRequest` 요청을 그룹 코디네이터로부터 받은 `memberId`를 포함하여 전송한 후 그룹 코디네이터는 컨슈머 리더가 보낸 할당 결과를 토대로 각 컨슈머를 파티션에 할당
- 컨슈머는 그룹 코디네이터로부터 받은 할당 정보로 메세지 소비를 재개
- 컨슈머는 새로 할당받은 파티션에 필요한 데이터를 재구축

### 파티션 상태 재구축은 비효율성을 유발한다

![](https://images.ctfassets.net/gt6dp23g0g38/75Mb2DDsnsQ1rzhovE93NF/f254f9bc114fc01f05b2c005ef5c2aff/Kafka_Internals_077.png)

- 만약 컨슈머가 파티션에 있는 레코드를 기반으로 상태를 유지할 경우, 리밸런싱이 진행되면, 해당 상태를 유지하기 위해 모든 레코드들을 다시 읽어야 함
- 컨슈머가 기존 파티션을 그대로 사용하게 되었음에도 불구하고, 기존 파티션을 취소한 후 재할당되었기 때문에 컨슈머는 정리된 상태를 다시 만들기 위해 추가 시간을 들여야 함

### 파티션 리밸런싱은 메세지 소비 중단을 유발한다

![](https://images.ctfassets.net/gt6dp23g0g38/a030ERMpe6aBI0q2rtRAM/44bd23b209e40d7f7543e83c6de3fea3/Kafka_Internals_078.png)

- 모든 파티션을 재할당하는 리밸런싱은 리밸런싱이 발생할 때 모든 프로세스가 일시 중단(**stop-the-world**) 되는 문제를 야기
- 이는 파티션 소유권 변경을 위해 모든 컨슈머의 파티션을 취소하기 때문에 발생하는 것으로, 파티션이 컨슈머에 재할당될 때까지 일시 중단은 유지
- 기존 파티션을 유지할 경우, 중단 없이 프로세스를 진행할 수 있음에도 모든 파티션 소유권을 취소하는 것은 비효율적

### 스티키 파티션 전략은 상태 재구축을 방지한다

![](https://images.ctfassets.net/gt6dp23g0g38/184ENnaTGeHTXyToly3Oj5/2b939e740df21123c6cc1fa91bb80abc/Kafka_Internals_079.png)

- 스티키 파티션 전략을 사용할 경우, 상태 정리 프로세스를 재할당이 끝난 이후로 연기
- 만약 컨슈머가 기존 파티션에 재할당되면, 상태 재구축 없이 메세지 소비 프로세스를 바로 실행
- 위 사례에서 **Consumer1**은 **p2** 파티션 관련 상태만 정리

### 협력적 스티키 파티션 전략은 **stop-the-world**를 최대한 줄임

- step 1
  ![](https://images.ctfassets.net/gt6dp23g0g38/4hxCepzIy6fhVRFvg3LJjr/a09433afda0ce6cbaa560acf8e3daafa/Kafka_Internals_080.png)
  - 어떤 파티션 할당이 취소되어야 하는지 판단
  - 1단계 마지막에 해당 파티션 할당을 취소
  - 파티션 할당이 취소되지 않은 나머지 컨슈머는 기존 파티션으로 메세지 소비를 일시 중단 없이 계속 진행
- step 2
  ![](https://images.ctfassets.net/gt6dp23g0g38/3rsYzgAy1qklrJzVCRQ74u/93f70ccd8442c10d8be32a56e5c64c45/Kafka_Internals_081.png)
  - 할당 취소된 파티션만 컨슈머에게 할당
  - 복잡한 시스템에서는 모든 파티션이 할당 취소 후 재할당이 생길 수 있음
  - 하지만 그 중 일부라도 파티션 할당 취소가 필요 없을 경우, 이 전략을 사용하면 해당 컨슈머는 일시 중단 없이 계속 메세지를 소비하는 이점 존재

## 스태틱 멤버십은 컨슈머 재시작 과정에서 발생하는 리밸런싱을 피할 수 있다

![](https://images.ctfassets.net/gt6dp23g0g38/4nNPDs11L8OfiTtOfl7Ket/6b08a07f522090245224538c9f621c04/Kafka_Internals_082.png)

- 운영 과정에서 하드웨어 점검이나 소프트웨어 업데이트 등의 이유로 컨슈머를 순차적으로 재시작해야 하는 경우 발생
- 하트비트나 세션 타임아웃 설정으로 인해 컨슈머를 재시작할 경우 리밸런싱 유발
- 컨슈머 그룹 내에서 컨슈머를 식별하기 위한 ID를 부여하게 되는데, 컨슈머가 재시작 되면 동일한 컨슈머여도 식별 ID가 다시 부여되어 새로운 컨슈머로 인식
- 컨슈머 식별 ID를 `group.instance.id`로 설정하여 기존 컨슈머로 인식
  - `group.instance.id`은 컨슈머 마다 고유한 값을 가져야 함
- 스태틱 멤버십 기능을 적용할 경우, 해당 컨슈머는 그룹을 떠날 때 그룹 코디네이터에게 알리지 않음
- 하트비트를 기다리는 시간인 `session.timeout.ms`를 컨슈머 재시작 시간보다 크게 설정하여, 하트비트가 재시작이 완료될 때까지 그룹 코디네이터에게 전송되지 않아도 리밸런싱이 일어나지 않도록 해야 함
