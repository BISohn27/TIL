# 카프카 트랜잭션 메세지가 아직 커밋되지 않았는데 일반 메세지가 들어오면 어떻게 되는가?

카프카 프로듀서의 트랜잭션 기능에 대한 정보를 찾아보다 문득 생긴 의문이 있다. 카프카 프로듀서의 트랜잭션 기능은 기본적으로 카프카 프로듀서마다 설정을 할 수 있다. 따라서 같은 토픽에 트랜잭션으로 메세지를 보내는 프로듀서가 있을 수 있고, 일반 메세지로 보내는 프로듀서가 있을 수 있다.

> 프로듀서 마다 트랜잭션 여부를 설정할 수 있으면, 메세지가 뒤 섞여 들어오는 상황에서는 대체 어떻게 처리가 되는걸까? 특히 트랜잭션이 완료되기 전 일반 메세지가 들어와 트랜잭션 메세지와 컨트롤 메세지가 연속적으로 저장되지 않은 상황에서 컨슈머는 어떤 메세지를 가져가게 되는걸까?

## `isolation.level=read_committed`는 LSO를 사용한다.

![](https://images.ctfassets.net/gt6dp23g0g38/3oGsworc81rJJVhhm4GmW2/5e18a109b7078ed2ac97251ecc919e34/Kafka_Internals_102.png)
컨슈머를 `isolation.level=read_committed`로 설정할 경우, LSO(last stable offset) 이하의 offset인 메세지 만 브로커에서 response로 반환한다. LSO는 현재 보류중인(아직 트랜잭션이 끝나지 않은) 메세지들의 offset 중 가장 작은 값을 나타내는 것으로, 브로커는 컨슈머의 요청에 **LSO보다 작은 offset을 가진 메세지까지**만 반환한다.  
따라서 컨슈머는 트랜잭션이 성공하거나 실패한 메세지만을 읽을 수 있고, 트랜잭션 메타데이터는 레코드에 포함되어 반환되기 때문에 컨슈머에서는 메타데이터를 확인하여 실패한 트랜잭션 메세지는 버리고 작업을 진행할 수 있다.  
위 내용을 토대로 유추해보면, 트랜잭션이 완료되지 않은 메세지가 있을 경우 LSO가 해당 메세지 offset 이하(트랜잭션이 아직 완료되지 않은 메세지가 더 있고, 그 메세지의 offset이 더 작을 경우)로 설정되기 때문에 이 메세지 뒤로 커밋이 완료된 메세지가 존재하더라도 컨슈머는 읽을 수 없다. 그러므로 이후 메세지는 트랜잭션이 완료되어야지만 처리 가능하다는 것을 유추할 수 있다.  
이는 트랜잭션 처리 로직 내 지연이 생길 수 있는 작업이 있을 경우, 해당 트랜잭션에 영향 받는 모든 파티션의 처리 지연이 생길 수 있다는 것도 유추 가능하다.  
물론 트랜잭션 타이머(`transaction.timeout.ms`, 기본값 1분)이 작동하기 때문에 설정 값 내로 트랜잭션이 완료되지 않을 경우, 실패 처리 된다. 실패 후에는 다시 정상적으로 메세지 처리가 되지만 지연이 생길 수 있는 로직을 넣지 않는 것이 메세지 처리량 증가를 위해 좋을 것 같다.
