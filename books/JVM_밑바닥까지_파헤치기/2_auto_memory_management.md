# 2. 자동 메모리 관리

## 런타임 데이터 영역

- 자바 가상 머신은 프로그램 실행에 필요한 메모리를 여러 개의 데이터 영역으로 나눠 관리
- 각 영역은 고유의 목적과 생성/삭제 시점이 존재
    - 가상 머신 프로세스의 시작과 동시에 만들어지는 영역이 있고, 사용자 스레드의 시작/종료에 맞춰 생성/삭제 되는 영익이 존재
- 생성/삭제 시점에 따라 2개로 분류되고, 세부적으로는 5개의 영역으로 구분
    - 가상 머신 프로세스와 라이프 사이클이 일치
        - 메서드 영역
            - 런타임 상수 풀
        - 힙
    - 사용자 스레드와 라이프 사이클이 일치
        - 가상 머신 스택
        - 네이티브 메소드 스택
        - 프로그램 카운터 레지스터

### 프로그램 카운터

- 현재 실행 중인 스레드의 ‘바이트코드 줄 번호 표시기’
- 바이트코드 인터프리터는 카운터 값을 변경하여 다음 실행할 바이트코드 명령어 선택
- 프로그램의 제어 흐름, 분기, 순환 점프 등과 예외 처리나 스레드 복원 같은 모든 기능에 프로그램 카운터 활용
- 여러 스레드가 CPU 코어에서 실행될 때, 각 코어에서는 한 스레드의 명령어만 실행 가능
    - 스레드 전환 후 이전 실행 지점을 정확하게 복원해야 하기 때문에 각 스레드 마다 고유의 프로그램 카운터
    
      → **스레드 프라이빗 메모리**
    
- 자바 메소드 실행 중일 경우, 실행 중인 바이트코드 명령어 주소가 기록
- 네이티브 메소드를 실행 중일 경우, *Undefined* 기록
- **OutOfMemoryError** 조건이 JVM 명세서에 정의되어 있지 않음

### 자바 가상 머신 스택

- **스레드 프라이빗 메모리**
- 연결된 스레드와 라이프 사이클이 동일
- 각 메소드가 호출 될 때 마다 스택 프레임이 생성되어 **지역 변수 테이블**, **피연산자 스택, 동적 링크**, **메소드 반환값** 등의 정보 저장
- 생성된 스택 프레임을 **Push**하고, 메소드가 끝나면 **Pop** 반복
- 자바에서 스택이라 하면 **자바 가상 머신 스택**을 보통 의미하고, 그 중 특히 **지역 변수 테이블**을 ****의미

- 지역 변수 테이블
    - 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장
    - 데이터 타입들을 저장하는 **지역 변수 슬롯**
        - 일반적으로 32비트
        - 64비트인 Double 등은 2개의 슬롯에 하나의 데이터 타입 저장
        - 지역 변수 테이블의 데이터 공간은 컴파일 타임에 이미 결정 되어 있음 → 크기는 **슬롯**
        - **슬롯**의 실제 크기는 가상 머신 구현에 따라 달라짐
    - 스택은 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 크면 **StackOverflowError** 발생
    - 스택 용량을 동적으로 확장할 수 있는 가상 머신의 경우 스택 확장 시점에 여유 메모리가 없으면 **OutOfMemoryError** 발생
      
        → 컴파일 타임에 스택 크기가 결정되는 핫스팟에서는 발생하지 않음
        

### 네이티브 메소드 스택

- 가상 머신 스택과 유사하며, 가상 머신 스택이 자바 메소드(바이트코드)를 실행할 때 사용한다면 **네이티브 메소드 스택**은 **네이티브 메소드**를 실행할 때 사용
- JVM 명세에는 어떤 구조로 네이티브 메소드 스택을 구현해야 하는지 정의 하지 않음
- 가상 머신 스택처럼 **스택 깊이가 깊으면** **StackOverflowError, 스택 확장에 실패**하면 **OutOfMemoryError** 발생

### 자바 힙

- 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리 공간
- 자바의 모든 스레드가 공유하고, JVM의 라이프 사이클과 일치
- **객체 인스턴스 저장**이 목적
- ‘거의’ 모든 객체 인스턴스가 이 영역에 할당
  
    → 추후 값 타입이 지원으로 다른 곳에 저장될 가능성 존재 (Project Valhalla)
    
- GC가 관리하는 영역
- 세대 별 컬렉션 이론을 기초로 GC가 설계 된 경우가 많기 때문에 **New(Eden, Survivor), Old**로 설명하는 경우도 있음
    - 설계 방식 중 하나라서 반드시 위의 구조로 구성해야 하는 것은 아님
    - 세대 단위 설계를 하지 않은 컬렉터도 개발(ZGC(세대 단위도 존재), Shenandoah(세대 단위 개발 중))
- 모든 스레드에서 공유하기 때문에 객체 할당 효율을 높이기 위해 스레드 로컬 할당 버퍼 여러 개로 나뉨
  
    → 어떻게 나뉘든 객체는 힙에 할당 된다는 대전제는 현재로서는 달라지지 않음
    
- 자바 힙을 작게 구분하는 목적은 오직 메모리 회수와 할당을 더 빠르게 하기 위함
- JVM 명세에 따르면 힙은 **물리적으로는 떨어져 있어도** 상관 없으나 **논리적으로는 연속** 되어야 함
    - 대다수 가상 머신은 큰 객체(주로 배열)은 물리적으로 연속된 메모리 공간을 사용하도록 구현
- `-Xmx(최대 크기)` 와 `-Xms(최소 크기)` 를 설정하여 자바 힙의 크기를 조절하며, 공간을 더 확장할 수 없을 경우에는 **OutOfMemoryError** 발생

### 메소드 영역

- 메소드 영역은 물리적인 영역이 아니라 논리적인 영역
    - JDK 7까지는 **PermGen** 영역에 메소드 영역 데이터를 저장했으나 JDK 8부터는 **메타스페이스**와 **힙**에 저장
        - **메타스페이스**
            - 클래스 메타 데이터 - 클래스 이름, 상속 정보 등 저장
            - PermGen의 크기는 JVM 옵션이나 기본 값으로 정해져 있기 때문에 사전에 정해진 크기 이상으로 메모리 할당을 시도하면 OOM이 발생할 수 있어 크기가 정해져 있지 않은 **네이티브 메모리**에 할당하도록 변경
                - 기본적으로 **네이티브 메모리**로 구현할 경우 운영체제에서 제한한 크기(32비트 운영체제의 경우 4G)까지 할당 가능
        - **정적 클래스 변수** 등은 **힙**에 별도로 저장
- 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는데 이용
- 메소드 영역을 JVM 명세에서 논리적으로 힙의 한 부분으로 기술하지만 자바 힙과 구분하기 위해 **논 힙**이라 부리기도 함
- JVM 명세에 의해 메모리 할당을 더이상 하지 못할 경우 **OutOfMemoryError** 발생

### 런타임 상수 풀

- 메소드 영역의 일부
- **클래스 버전, 필드, 메소드, 인터페이스** 등 클래스 파일에 포함된 **설명 정보**와 컴파일 타임에 생성 된 다양한 **리터럴**과 **심벌 참조**가 저장
- 클래스 파일의 각 영역 별로 JVM 명세에 엄격한 규칙을 정해 놓았기 대문에 클래스 파일 로드 시 명세가 요구하는 데이터가 각 바이트 포함되어 있어야 함
- 런타임 상수 풀의 경우 JVM 명세에 요구 사항이 상세하게 정의되어 있지 않기 때문에 가상 머신 제공자의 구현에 따라 달라짐
- 일반적으로 **심벌 참조**와 심벌 참조로부터 번역된 **직접 참조** 역시 **런타임 풀**에 저장
- **런타임 상수 풀**의 경우 **동적**으로 생성될 수 있음
  
    → **클래스 파일의 상수 풀**처럼 컴파일 타임에 생성되어야 하는 것은 아님
    
    - String `intern()` 메소드처럼 런타임에 상수 생성 가능
- 메소드 영역이기 때문에 메소드 영역 크기 내에서만 할당 되어야 하며, 크기 제한으로 더 이상 할당하지 못할 경우에는 **OutOfMemoryError** 발생

### 다이렉트 메모리

- JVM 명세에 정의되어 있는 가상 머신 런타임에 속하지 않음
- **NIO** 도입으로 힙이 아닌 네이티브 메모리에 직접 할당 할 수 있는 네이티브 함수 라이브러리를 사용하여, **DirectByteBuffer** 객체를 통해 네이티브 메모리에 직접 할당 가능
  
    `ByteBuffer buffer = ByteBuffer.allocateDirect(int capacity);` 
    
- 자바 힙에 데이터를 복사해서 사용하지 않아도 되기 때문에 성능 이점 존재
- 물리 메모리에 할당하기 때문에 자바 힙 크기와 무관
- 총 메모리 용량과 프로세서가 다룰 수 있는 주소 공간(일반적으로 32비트, 64비트) 넘을 수 없음
- 물리적 제약과 운영체제 수준의 제약을 넘어 동적 할당을 시도할 경우 **OutOfMemoryError** 발생
