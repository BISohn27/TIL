# 자바 메모리 모델과 스레드

- 여러 작업을 동시에 수행하는 이유:
  - 컴퓨터의 연산 능력 극대화
  - 컴퓨터의 연산 성능과 저장, 통신 성능(일반적으로 IO 성능)의 격차가 너무 크기 때문
- 동시에 여러 작업을 처리 -> 컴퓨터 연산과 관계 없는 작업(IO 작업) 시 컴퓨터 연산을 다른 작업에 투입하는 것
- 서비스를 여러 클라이언트에 동시에 제공해야 하는 상황
  - 계산량이 똑같은 작업을 수행할 때 프로그램이 스레드를 동시에 더 많이 운용할 수록 효율은 높아짐(더 많은 요청을 동시에 처리)
  - 스레드 간 경합이 많을수록(다른 스레드를 멈춰 세우거나 교착 상태에 빠지는 등) 동시성은 크게 감소

## 하드웨어에서의 효율과 일관성

- 물리 머신에서 동시성 문제는 가상 머신의 동시성 문제와 비슷
- 컴퓨팅 작업이 단순히 프로세서의 '**컴퓨팅**' 만으로 이뤄질 수 없다는 것이 '여러 작업을 동시에 실행'와 '컴퓨터 프로세서 성능을 최대한 끌어 올림'을 어렵게 만드는 주 원인
- 컴퓨팅 작업은 레지스터만을 사용하여 작업을 완료할 수 없음 -> 레지스터에 비해 상대적으로 느린 메모리를 사용할 수 밖에 없는 구조
  - 속도 차를 극복하기 위해 다양한 **캐시 계층**을 사용
    - 필요한 데이터를 캐시에 복사하고 작업
    - 작업이 완료된 데이터를 캐시에서 메모리로 동기화
    - 각 프로세서는 메인 메모리를 공유하지만 캐시 자체는 자신의 것을 사용  
      ![alt text](https://media.springernature.com/lw685/springer-static/image/prt%3A978-0-387-09766-4%2F19/MediaObjects/978-0-387-09766-4_19_Part_Fig1-142_HTML.gif)
    - 중간 캐시 계층으로 인해 '**캐시 일관성**' 문제 발생
      - 프로세서 별캐시 데이터가 서로 다름
      - 메인 메모리 동기화 시 "어느 프로세서의 데이터를 기준으로 동기화를 해야 하는가?" 문제 직면
      - 이 문제를 해결하기 위해 특정 프로토콜을 따라 메모리 동기화 진행
      - 아키텍처가 다른 물리 머신은 메모리 모델이 다르기 때문에 사용하는 프로토콜도 다름
  - **비순차 실행 최적화**를 통해 컴퓨팅 능력 향상
    - 입력 코드에 기술된 명령어 순서와 다르게 프로세서에서 명령어를 실행하는 것
    - **JIT** 컴파일러에서 **명령어 재정렬 최적화**와 비슷

## 자바 메모리 모델

- 자바는 운영 체제 및 하드웨어 간 메모리 모델 차이를 극복하기 위해 자체적인 **자바 메모리 모델** 정의
- **자바 메모리 모델**은 논리적인 메모리 구조 -> "어떻게 동기화를 할 것인가?"에 대한 프로토콜
- 여러 스레드가 메모리에 동시에 접근해도 모든 작업이 명확하게 이루어지도록 엄격하게 정의 필요
- 가상 머신에서 하드웨어의 다양한 기능(레지스터, 캐시, 명령어 집합의 특정 명령어 등)을 활용하여 성능을 높일 여지도 남겨야 함

### 메인 메모리와 작업 메모리

- 자바 메모리 모델의 주된 목적: 프로그램에서 다양한 **변수에 접근하는 규칙**을 정의
- 가상 머신의 메모리에서 **변수**에 값을 저장하고 가져오는 저수준의 정보에 초점
  - **변수**: 인스턴스 필드, 정적 필드, 배열 객체의 원소 (지역 변수와 메서드 매개변수는 제외)
- 결국 자바 메모리 모델은 멀티 스레드 환경에서 스레드 경합이 발생할 변수의 처리를 어떻게 하는지가 초점
- 자바 메모리 모델: 모든 변수가 메인 메모리(가상 머신이 관리하는 메모리)에 저장된다고 규정
- 각 스레드는 물리 머신에서 각 프로세서들이 자기만의 캐시를 가지는 것처럼 각 스레드가 자기만의 작업 메모리를 가짐
- 작업 메모리 변수 -> 메인 메모리에 저장된 변수의 복사본
  - 스레드는 자신의 작업 메모리에 복사한 값을 사용하고, 메인 메모리에 직접 접근 불가
  - 다른 스레드의 작업 메모리에도 직접 접근 불가
- 메인 메모리와 작업 메모리는 자바 힙, 스택, 메서드 영역과는 관련 없는 논리적인 모델
- 대응 관계를 굳이 따지면 메인 메모리 -> 자바 힙, 작업 메모리 -> 스택

### 메모리 간 상호 작용

- 메인 메모리와 작업 메모리 간 프로토콜 (메인 메모리에서 작업 메모리로 변수 복사, 작업 메모리에서 메인 메모리로 동기화)
  - 8개로 정의
  - 각 단계의 연산은 원자적으로 이뤄지도록 보장 (double과 long은 일부 플랫폼에서 예외 허용)
  - 연산 단계
    - lock: 메인 메모리에 존재하는 변수를 특정 스레드만 사용
    - unlock: 잠겨 있는 변수를 잠금 해제
    - read: load 연산을 위해 메인 메모리의 변수값을 특정 스레드의 작업 메모리로 전송
    - load: read 연산으로 메인 메모리로부터 가져온 값을 작업 메모리의 변수에 복사
    - use: 작업 메모리의 변수값을 실행 엔진으로 전달  
      -> 가상 머신의 변수 값 사용 바이트코드 명령어를 만날 때마다 실행
    - assign: 실행 엔진에서 얻은 값을 작업 메모리의 변수에 할당  
      -> 가상 머신의 할당 바이트코드 명령어를 만날 때마다 실행
    - store: write 연산을 위해 작업 메모리의 변수 값을 메인 메모리로 전송
    - write: store 연산으로 작업 메모리에서 얻은 값을 메인 메모리의 변수에 기록
  - 메인 메모리 -> 작업 메모리
    - read -> load 순서로 반드시 수행
  - 작업 메모리 -> 메인 메모리
    - store -> write 순서로 반드시 수행
  - 연산 단계는 순서대로 수행되어야 하는 것이지 바로 이어서 수행되어야 하는 것은 아님
  - 연산의 수행 규칙
    - read - load, store - write 는 항상 묶어서 수행되어야 함
    - 작업 메모리에 assign 연산이 발생하면 반드시 메인 메모리로 동기화 해야 함
    - 스레드는 작업 메모리의 데이터를 assign 없이 메인 메모리로 동기화 불가
    - 변수의 생성은 메인 메모리에서만 가능, 작업 메모리에 있는 초기화(load, assign)되지 않은 변수는 곧바로 사용 불가  
      -> 변수 use 또는 store 전에 load, assign이 이뤄져야 함
    - 변수는 한번에 한 스레드에 의해서만 lock될 수 있고, lock을 획득한 스레드는 여러번 lock을 수행할 수 있음. 만약 여러번 lock이 수행되면, lock 수행된 만큼 unlock 필요
    - 잠겨 있지 않은 변수나 다른 스레드가 잠근 변수에 lock 연산 불가
    - unlock을 하기 위해서는 변수를 메인 메모리에 store, write 필요

### volatile

- 가상 머신이 제공하는 가장 가벼운 동기화 메커니즘
- volatile을 정의하는 2가지 특성
  - 모든 스레드에서 volatile로 선언된 변수를 투명하게 볼 수 있음 (가시성 보장)
    - 한 스레드에서 값을 수정하면, 다른 스레드에서 즉시 수정된 값을 확인
    - 일반 변수: 메모리의 값이 메인 메모리를 거쳐 전달
      예) 스레드 A에서 수정한 변수는 A가 수정된 값을 write 연산까지 진행 한 후 스레드 B에서 다시 read, load를 해야 함
    - volatile 변수: 각 스레드의 작업 메모리의 변수 일관성에 문제 없음
      - 작업 메모리에 load된 volatile 변수 간 값이 일치하지 않을 수 있음
      - use 하기 전 매번 새로 고치는 작업을 하기 때문에 "**실행 엔진이 일관되지 않은 값을 사용할 일이 없다**" 의미
      - volatile 변수가 동시성 환경에서 안전을 보장하지는 않음
        - volatile은 변경된 변수 값을 항상 사용
        - 다른 스레드에서 해당 변수를 변경하는 것을 막지는 않음(lock이 아님)
        - 변수를 변경하는 연산 후 메인 메모리로 동기화하는 작업 전 다른 스레드에서 값을 변경  
          -> 스레드는 이미 연산 작업을 수행 후 다른 스레드에서 변경한 값이 피연산자 스택에 load되기 때문에 연산 결과가 적용되지 않은 값이 동기화
      - lock을 통해 volatile 변수 연산 원자성을 보장해야 하는 경우
        - 변수 값을 수정하는 스레드가 하나가 아니거나, 연산 결과가 변수의 현재 값과 연관되어 있는 경우
        - 다른 상태 변수와 불변성 제약 조건이 연관되어 있는 경우
  - 명령어 재정렬 최적화가 수행되지 못하도록 함
    - 일반 변수의 경우 할당 결과를 사용해야 하는 모든 위치에서 올바른 결과를 얻는 점만 보장, 올바른 결과를 보장하기만 하면 변수 할당 작업 실행 순서와 프로그램 코드 순서가 다를 수 있음
      - 특정 상태를 표시하는 변수가 의미적으로 다른 로직이 먼저 수행됨을 보장하는 표시인 경우, JIT 컴파일러는 해당 sementic을 모르기 때문에 할당 연산을 먼저 수행하는 최적화 수행 가능
    - 하드웨어 관점에서도 일관된 결과를 보장하면, 명령어 재정렬이 발생
      - 하드웨어 관점에서 일관된 결과는 연산되는 데이터에 한정되기 때문에 의미적 연산 순서는 보장되지 않음
      - volatile 키워드는 가시성 보장을 위해 할당 등의 작업 시 메모리 장벽 (메모리 장벽이 설정된 이후 명령어는 장벽 앞으로 재정렬되지 않음)을 통해 명령어 재정렬을 막음
- volatile의 중요성
  - 락 방식이 아니기 때문에 성능 향상 (락이 필요없는 상황에서는 락을 제거하는 최적화 때문에 정량적인 측정은 불가능)
  - 읽기 성능은 일반 변수와 동일하고, 쓰기 성능은 일반 변수보다 느림
    - 명령어 재정렬을 막는 메모리 장벽이 포함되기 때문
    - 하지만 모든 상황에서 락보다는 성능이 좋음
- volatile 변수의 연산 규칙
  - 작업 메모리에서 volatile 변수가 use 될 때마다 가시성 보장을 위해 항상 메인 메모리에 최신 값으로 새로 고처야 함
  - 작업 메모리에서 volatile 변수가 수정될 때마다 메인 메모리로 즉시 동기화 되어 다른 스레드에서 해당 변수 변경 사항을 볼 수 있도록 보장
  - 한 스레드 내에서 두 volatile 변수에 대한 사용 로직이 있을 때, 특정 volatile 변수를 use or assign이 먼저 발생하면, 해당 변수를 store, load, write 하는 연산은 항상 다른 volatile 변수의 연산들보다 우선 (명령어 재정렬 방지)
