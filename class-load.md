# 7장. 클래스 로딩 메커니즘

## 클래스 로딩 메커니즘
- 자바 가상 머신은 클래스를 설명하는 데이터를 클래스 파일로부터 메모리로 읽음
- 로드된 파일을 `검증 -> 변환 -> 초기화` 후 자바 타입을 생성
- 자바 언어는 클래스 로딩, 링킹, 초기화가 모두 **프로그램 실행 중**에 이뤄짐 -> 클래스 로딩을 거치기 때문에 실행 성능이 살짝 떨어짐
  - 자바 애플리케이션의 높은 확장성과 유연성을 위한 트레이드 오프 (동적 로딩과 동적 링킹)
  - 런타임에 실제 구현 클래스를 결정할 수 있기 때문에 코드 일부를 바이너리 형태로 네트워크 등에서 읽어 올 수 있음
   
## 타입의 라이프 사이클
- 단계
  1. 로딩
  2. 링킹
     - 검증
     - 준비
     - 해석
  4. 초기화
  5. 사용
  6. 언로드
- 로딩, 검증, 준비, 초기화, 언로딩은 반드시 순서대로 이뤄짐
- 해석(Resolution) 단계는 초기화 후에 시작 가능 (lazy binding을 지원하기 위해)
- 각 단계의 순서의 의미는 '완료' 시점이 아니라 **'시작'** 시점
  - 한 단계를 진행하는 중간에 다음 단계를 호출해 시작하는 등 병렬 진행이 가능
   
## 각 단계 시작 시점
- 로딩 단계는 JVM 명세에 어느 상황에서 시작해야 되는지 명시되어 있지 않음 -> JVM 구현자가 자유롭게 선택 가능
- **active reference**: 초기화 단계는 JVM 명세에 **6가지 즉시 시작되어야 하는 상황**을 엄격히 규정
  - 바이트 코드 명령어 **new**, **getstatic**, **putstatic**, **invokestatic**을 만났을 경우, 해당 타입이 초기화 되지 않았다면 즉시 초기화
    - new 키워드로 인스턴스 생성
    - 타입의 정적 필드를 읽거나 설정(final 정적 필드의 경우 컴파일 타임에 상수 풀에 채워지므로 제외)
    - 타입의 정적 메소드 호출
  - **Class 클래스**나 **java.lang.reflect 패키지** 등 표준 클래스 라이브러리에서 리플렉션을 사용할 때 초기화 되지 않은 타입은 즉시 초기화
  - 클래스 초기화 시 상위 클래스가 초기화 되어 있지 않으면 상위 클래스 초기화 (단, 인터페이스의 경우 상위 인터페이스는 초기화 하지 않음 -> 상위 인터페이스는 실제 상위 인터페이스가 사용될 때 초기화)
  - JVM에 의해 main 메소드가 실행될 때 main 메소드의 타입을 먼저 초기화
  - java.lang.invoke.MethodHandle 인스턴스를 호출할 때 해당 클래스가 초기화 되어 있지 않다면 초기화
  - 인터페이스에 디폴트 메소드를 정의했을 경우, 인터페이스를 직간접적으로 구현한 클래스가 초기화될 때 **인터페이스부터** 초기화
* **passive reference**: 타입 초기화를 촉발하지 않는 모든 참조 방식
  - 정적 필드를 참조할 때 필드를 직접 정의한 클래스만 초기화
    - 하위 클래스의 로딩과 검증 단계 촉발 여부는 JVM 명세에 정의 되어 있지 않기 때문에 JVM 구현자에 따라 다름 (핫스팟 JVM의 경우 하위 클래스를 로드)
    ```
    class SuperClass {
      static {
        System.out.println("super init");
      }

      public static int value = 1;
    }

    class SubClass extends SuperClass {
      static {
        System.out.println("sub init");
      }
    }

    class Main {
      public static void main(String[] args) {
        System.out.println(SubClass.value); // super init 만 출력
      }
    }
    ```
  - 타입의 배열을 생성할 경우, 타입의 원소는 초기화하지 않고 타입을 원소로 가지는 배열 클래스(일차원 배열을 감싼 클래스) `[Ltest.SuperClass`를 생성
    - 배열을 감싼 클래스를 만들기 때문에 c,c++과 달리 배열의 크기를 벗어난 원소에 접근 불가 (**ArrayIndexOutOfBoundsException** 발생)
